[toc]

## 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？


### 为什么需要复杂度分析？

1. 我们需要一个**不用具体的测试数据来测试**，就可以**粗略地估计**算法的执行效率的方法。

### （大 O 复杂度表示法）概念

1.  表示代码执行时间随数据规模增长的**变化趋势。**
2.  也叫作**渐进时间复杂度**，简称**时间复杂度**。

### （时间复杂度分析）方法

1.  只关注循环**执行次数最多**的一段代码
2.  加法法则：总复杂度等于**量级最大**的那段代码的复杂度
3.  乘法法则：嵌套代码的复杂度等于**嵌套内外代码复杂度的乘积**。

### 几种常见时间复杂度实例分析

1.  复杂度量级
    -   ![img](imgs/3723793cc5c810e9d5b06bc95325bf0a.jpg)
2.  **多项式量级**和**非多项式量级**。
    -   其中，非多项式量级只有两个：`O(2^n)` 和 `O(n!)`
    -   下面我们主要看几种常见的**多项式时间复杂度**

#### **O(1)**

1. 一般情况下，只要算法中不存在**循环语句、递归语句**，即使有成千上万行的代码，其时间复杂度也是 `O(1)`。

#### **O(logn)、O(nlogn)**

1.  采用大 O 标记复杂度的时候，可以忽略**系数**。

#### **O(m+n)、O(m*n)**

1.  代码的复杂度**由两个数据的规模**来决定。我们**无法事先评估 m 和 n 谁的量级大**，所以，我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，下面代码的时间复杂度就是 `O(m+n)`。

    -   ```c
        int cal(int m, int n) {
          int sum_1 = 0;
          int i = 1;
          for (; i < m; ++i) {
            sum_1 = sum_1 + i;
          }
        
          int sum_2 = 0;
          int j = 1;
          for (; j < n; ++j) {
            sum_2 = sum_2 + j;
          }
        
          return sum_1 + sum_2;
        }
        
        ```

2.  乘法法则，继续有效：`T1(m)*T2(n) = O(f(m) * f(n))。`

### （空间复杂度分析）概念

1.  空间复杂度全称就是**渐进空间复杂度**，表示算法的存储空间与数据规模之间的**增长关系**
2.  常见的空间复杂度就是 **`O(1)`、`O(n)`、O($n^2$)** 

### 内容小结

1.  常见的复杂度并不多，从低阶到高阶有：`O(1)`、`O(logn)`、`O(nlogn)`、O($n^2$)
    -   ![img](imgs/497a3f120b7debee07dc0d03984faf04.jpg)
2.  **复杂度分析并不难，关键在于多练。**

## 课后思考

+ 有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？你怎么看待这个问题呢？

### 精选留言

1.  #xr

    >   + 首先，我不认为这是多此一举
    >
    >       
    >
    >   + **渐进时间、空间复杂度分析为我们提供了一个很好的理论分析的方向**。并且它是与宿主平台无关的，能够让我们对我们的程序有一个大致的认识，让我们知道，比如最坏情况下程序的执行效率如何，同时也**为我们交流提供了一个不错的桥梁**。我们可以说，算法 1 的时间复杂度是 O(n)，算法 2 的时间复杂度是 O(logn),**这样我们就立刻就对不同的算法有了一个“效率”上的感性认识。**
    >
    >       
    >
    >   + 当然，渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得 O(logn) 的算法一定优于 O(n)，针对不同的宿主环境，不同的数据集，不同的数据量大小，在实际应用上面可能真正的性能会不同。个人觉得，针对不同的实际情况，进而进行一定的性能基准测试，是很在必要的，比如统一一批手机上（同样的硬件，系统等等）进行横向基准测试，进而选择适合特定应用场景下的最优算法。
    >
    >       
    >
    >   + 综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是**相辅相成**的，**一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度的程序**。所以有实际的编程中，时刻关心理论时间、空间复杂度模型是有助于产出效率高的程序的，同时，因为渐进时式时间、空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多的时间，**重点在于在编程时，要具有这种复杂度分析的思维。**

2.  #姜威

    >   总结
    >
    >   一、什么是复杂度分析？
    >
    >   1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。
    >
    >   2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
    >
    >   3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
    >
    >   4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。
    >
    >   二、为什么要进行复杂度分析？
    >
    >   1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
    >
    >   2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。
    >
    >   三、如何进行复杂度分析？
    >   1.大O表示法
    >
    >   1）来源
    >   算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。
    >
    >   2）特点
    >   以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。
    >
    >   2.复杂度分析法则
    >
    >   1）单段代码看**高频**：比如循环。
    >
    >   2）多段代码取**最大**：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
    >
    >   3）嵌套代码求**乘积**：比如递归、多重循环等
    >
    >   4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。
    >
    >   四、常用的复杂度级别？
    >
    >   多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
    >   	O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
    >
    >   非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，
    >   	O(2^n)（指数阶）、O(n!)（阶乘阶）
    >
    >   五、如何掌握好复杂度分析方法？
    >
    >   复杂度分析关键在于多练，所谓孰能生巧。

