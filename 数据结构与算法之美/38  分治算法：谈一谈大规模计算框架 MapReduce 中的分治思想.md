[TOC]

## 38 | 分治算法：谈一谈大规模计算框架 MapReduce 中的分治思想

-   MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 GFS 和 Bigtable。
-   MapReduce 的本质就是我们今天要学的这种算法思想，分治算法。

### 如何理解分治算法？

-   为什么说 MapReduce 的本质是分治算法呢？
-   我们先来看，**什么是分治算法**？
    -   分治算法（divide and conquer） 的核心思想其实就是四个字，分而治之，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。
-   分治和递归的**区别**
    -   **分治算法是一种处理问题的思想，递归是一种编程技巧。**
-   分治算法的递归**实现**中，每一层递归都会涉及这样三个操作：
    -   分解，
        -   将原问题分解成一系列的子问题。
    -   解决，
        -   递归地求解各个子问题，若子问题足够小，则直接求解。
    -   合并，
        -   将子问题的结果合并成原问题。
-   分治算法能解决的问题，一般需要**满足下面这几个条件**：
    -   原问题与分解成的小问题具有相同的模式。
    -   原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法。
    -   具有分解终止条件，也就是说，当问题足够小时，可以直接求解。
    -   可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。

### 分治算法应用举例分析

-   背景

    -   假设，我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2， 逆序度就等于 0。
    -   相反，倒序排序的数据有序度就是 0，逆序度是 n/(n-1)/2。
    -   除了这两种极端情况外，我们通过有序对或逆序对的个数，来表示数据的有序度或或逆序度。
        -   ![img](https://static001.geekbang.org/resource/image/f4/20/f41fd0a83bc5c5b059f7d02658179120.jpg)

-   需求

    -   **如何编程求出一组数据的有序对个数或逆序对个数呢？**因为两者求解方式类似，我们这里只考虑逆序对个数求解方法。

-   最笨的求解方法

    -   拿每个数字跟它后面的数字比较，看有几个比它小的。
    -   我们把比它小的数字记作 k，通过这样的方式，把每个数字都考察一遍后，然后，对每个数字对应的 k 值求和。
    -   最后得到总和就是逆序对个数。
    -   时间复杂度
        -   **O(n^2^)**

-   分治思想求解

    -   先将数组 A 分成前后两半 A1 和 A2，分别计算 A1和 A2 的逆序对个数K1  和 K2，
    -   然后，再计算 A1 与 A2 间的逆序对个数 K3。
    -   那数组A 的逆序对个数就是 K1 + K2 + K3。

-   分治算法要求

    -   **子问题合并的代价不能太大**

-   如何快速借助归并排序算法来快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？

    -   归并排序的关键操作，将两个有序的小数组，合并成一个有序的数组。

    -   实际上，在这个合并的过程中，我们就可以计算出这两个小数组的逆序对个数。

    -   每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。

    -   图解

        -   ![img](https://static001.geekbang.org/resource/image/e8/32/e835cab502bec3ebebab92381c667532.jpg)

    -   代码实现

        -   ```java
            private int num = 0; // 全局变量或者成员变量
            
            public int count(int[] a, int n) {
              num = 0;
              mergeSortCounting(a, 0, n-1);
              return num;
            }
            
            private void mergeSortCounting(int[] a, int p, int r) {
              if (p >= r) return;
              int q = (p+r)/2;
              mergeSortCounting(a, p, q);
              mergeSortCounting(a, q+1, r);
              merge(a, p, q, r);
            }
            
            private void merge(int[] a, int p, int q, int r) {
              int i = p, j = q+1, k = 0;
              int[] tmp = new int[r-p+1];
              while (i<=q && j<=r) {
                if (a[i] <= a[j]) {
                  tmp[k++] = a[i++];
                } else {
                  num += (q-i+1); // 统计 p-q 之间，比 a[j] 大的元素个数
                  tmp[k++] = a[j++];
                }
              }
              while (i <= q) { // 处理剩下的
                tmp[k++] = a[i++];
              }
              while (j <= r) { // 处理剩下的
                tmp[k++] = a[j++];
              }
              for (i = 0; i <= r-p; ++i) { // 从 tmp 拷贝回 a
                a[p+i] = tmp[i];
              }
            }
            
            ```

        -   

### 分治思想在海量数据处理中的应用

-   我们前面讲的数据结构和算法，大部分都是基于内存存储和单机处理。但是，如果要处理的数据非常大，没法一次性放到内存中，这些数据结构和算法就无法工作了。
-   需求
    -   给 10 GB 的订单文件按照金额排序。
-   分析
    -   看似一个简单的排序问题，但是，数据量太大，有 10GB，而我们机器的内存可能有 2、3GB 这样，无法一次加载到内存，也就无法通过单纯地使用快排、归并基础算法来解决了。
-   解决思路
    -   要解决这种数据量大到内存装不下的问题，我们就可以利用分治思想。
    -   我们可以将海量数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决。
    -   然后再将小数据集合合并成大数据集合。
    -   实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或多机处理，加快处理的速度。
-   实现
    -   给 10GB 订单排序，我们可以先扫描一遍订单，
    -   根据订单金额，将10 GB 的文件划分为几个金额区间。
    -   这样每个小文件都可以单独加载到内存排序
    -   最后，将这些有序的小文件合并，就是最终有序的 10GB 订单数据了
    -   注意
        -   **网络开销**

### 解答开篇

-   为什么说 MapReduce 的本质就是分治思想？
    -   如果我们要处理的数据是 1T， 10T， 100T 这样子，那一台机器处理的效率肯定是非常低的。所以，面对如此海量的数据，利用集群并行处理显然是大势所趋。
    -   一台机器过于低效，我们把任务拆分到多台机来处理。如果拆分后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗？
    -   MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Brog 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Brog 中调度一台机器执行。

### 内容小结

-   今天，我们讲了一种应用非常广泛的算法思想，分治算法。
-   概括
    -   **分而治之**， 将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，最后再合并结果，就是原问题的解。
-   应用场景
    -   指导编码，降低问题求解的时间复杂度。
    -   解决海量数据处理问题，如 MapReduce 本质就是利用分治思想。
-   我们也时常感叹 Google 的创新能力如此之强，总是引领技术的发展。实际上，**创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优质架构的设计思想来源都是基础的数据结构和算法，这本身就是算法的魅力所在。**

### 课后思考

1.  还在哪些地方采用的分治算法的思想呢？

