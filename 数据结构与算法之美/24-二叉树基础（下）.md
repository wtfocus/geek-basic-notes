[TOC]

## 24 | 二叉树基础（下）： 有了如此高效的散列表，为什么还需要二叉树？

![](http://ww4.sinaimg.cn/large/006tNc79ly1g5p1s03mukj30vq0hsaan.jpg)

1.  **二叉查找树**，特点：
    -   支持**动态**数据集合的**快速插入、删除、查找**操作。
2.  开篇题
    -   散列表的时间复杂度是`O(1)`
    -   既然有了这么高效的散列表，为什么还需要用二叉树呢？

### 二叉查找树（Binary Search Tree）

1.  概念
	- 二叉查找树，也叫二叉搜索树。
    - 为实现**快速查找**而生。
    - 还支持**快速插入、删除**一个数据。
2.  特性
    - 在树中的任意一个节点
    - **左子树**中的每个节点的值，都要**小于**这个节点的的值，
    - **右子树**节点的值都**大于**这个节点的值。
    - ![img](imgs/f3bb11b6d4a18f95aa19e11f22b99bae-5223455.jpg)
3.  **查找**操作

    - 思路
        - 先取根节点，
        - 如果它**等于**我们要查找的数据，就**返回**。
        - 如果要查找的数据**比根节点**的值**小**，就在其**左子树**中递归查找。
        
    - 如果要查找的数据**比根节点**的值**大**，就在其**右子树**中递归查找。

    - 代码

      -   ```java
          public class BinarySearchTree {
            private Node tree;

            public Node find(int data) {
              Node p = tree;
              while (p != null) {
                      // 如果要查找的数据**比根节点**的值**小**，就在其**左子树**中递归查找。
                    if (data < p.data) p = p.left;
                      // 如果要查找的数据**比根节点**的值**大**，就在其**右子树**中递归查找。
                    else if (data > p.data) p = p.right;
                      // 如果它**等于**我们要查找的数据，就**返回**。
                    else return p;
              }
              return null;
            }

            public static class Node {
              private int data;
              private Node left;
              private Node right;

              public Node(int data) {
                this.data = data;
              }
            }
          }
        ```


4.  **插入**操作

    - **思路**

        - 插入过程类似查找操作
        - **新插入的数据一般都是在叶子节点上**
        - 我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。
            - 如果要插入的数据比节点的数据**大**，
                - 节点的右子树为**空**，就将新数据直接插到右子节点的位置。
                - 如果**不为空**，就再递归遍历右子树，查找插入位置。
            - 如果插入的数据比节点数值**小**，
              - 节点的左子树为**空**，就将新数据插入到左子节点的位置。
              - 如果**不为空**，就再递归遍历左子树，查找插入位置。
        - ![img](imgs/daa9fb557726ee6183c5b80222cfc5c5-5224003.jpg)

    - 代码

        - ```java
            public void insert(int data) {
              if (tree == null) {
                tree = new Node(data);
                return;
              }

              Node p = tree;
              while (p != null) {
                  // 插入数据比节点数据大
                if (data > p.data) {
                    // 右子节点为空，则直接插到右子节点的位置
                  if (p.right == null) {
                    p.right = new Node(data);
                    return;
                  }
                    // 右子节点不为空，则递归遍历右子树
                  p = p.right;
                    // 插入数据比节点数据小
                } else { // data < p.data
                    // 左子树为**空**，则直接插到左子节点的位置。
                  if (p.left == null) {
                    p.left = new Node(data);
                    return;
          }
                    // 左子节点不为空，则递归遍历左子树
          p = p.left;
                }
              }
            }
            
          ```
          

5.  **删除**操作

	- 思路：

	    1. **要删除的节点没有子节点**，我们只需要直接将父节点中，指向要删除节点的指针置为 null。如图 55。
	    2. **要删除的节点只有 一个子节点**，我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。如图 13。
	    3. **要删除的节点有两个子节点**。我们需要找到这个节点的右子树中最小的节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子节点，那就不是最小节点了）。所以，我们就可以应用上面两条规则来删除这个最小节点。如图 18
	    
	- ![img](imgs/299c615bc2e00dc32225f4d9e3490e2c-5224393.jpg)

	- 代码

	    - ```java
	        public void delete(int data) {
	          Node p = tree; // p 指向要删除的节点，初始化指向根节点
	          Node pp = null; // pp 记录的是 p 的父节点
	            
	            // 根据条件 data ，查找节点 p
	          while (p != null && p.data != data) {
	            pp = p;
	            if (data > p.data) p = p.right;
	            else p = p.left;
	  }
	          if (p == null) return; // 没有找到，则 return 
	        
	          // 要删除的节点有两个子节点
	          if (p.left != null && p.right != null) { // 查找右子树中最小节点
	            Node minP = p.right;
	            Node minPP = p; // minPP 表示 minP 的父节点
	              
	              // 查找最小节点
	            while (minP.left != null) {
	              minPP = minP;
	              minP = minP.left;
	            }
	      
	            p.data = minP.data; // 将 minP 的数据替换到 p 中
	            p = minP; // 下面就变成了删除 minP 了
	            pp = minPP;
	          }
	        
	            // 删除节点是叶子节点或者仅有一个子节点
	  	    Node child; // p 的子节点
	  	    if (p.left != null) child = p.left;
	  	    else if (p.right != null) child = p.right;
	  	      // 当前节点没有子节点，
	        else child = null;
	        
	          if (pp == null) tree = child; // 删除的是根节点
	          else if (pp.left == p) pp.left = child;
	          else pp.right = child;
	        }
	        
	      ```
	  
	- 扩展

	    - 标记删除法

	        >   就是单纯将要删除的节点，**标记**为“已删除”，并不真正从树中将这个节点去掉。
	        >
	        >   
	        >
	        >   分析
	        >
	        >   ​	浪费内存空间，
	        >
	        >   ​	删除操作变得简单
	        >
	        >   ​	没有增加插入、查找实现的难度。

6.  其他操作

    - 快速地查找**最大**节点和**最小**节点、**前驱**节点和**后继**节点
    - **中序**遍历二叉查找树，可以输出**有序**的数据序列，时间复杂度是 `O(n)`，非常高效。

### 操作重复数据

1.  针对两个**相同数据**的情况，这里有两种解决方法：

    1. 在每个节点中，通过**链表**和**数组**等数据结构，把相同的值存储在同一节点了。

    2. 把这个新**插入**的数据当作**大于**这个节点的值来处理。

        -   **查找**时，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树查找，直到遇到叶子节点，才停止。

        - **删除**时，先查找，然后依次删除。

### 时间复杂度分析

1.  如图一，根节点左右子树极度不平衡，那最坏时间复杂度是 `O(n)`。
2.  如图二，插入、删除、查找最好时间复杂度其实都是**跟树的高度成正比**，也就是 `O(hight)`。
3.  ![img](imgs/e3d9b2977d350526d2156f01960383d9-5225893.jpg)

### 解答开篇

1.  开篇题

    - 散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 `O(1)`，非常高效。
    - 二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 `O(logn)`。
    - 那我们**为什么还要用二叉查找树呢**？
2.  原因分析
    1. 有序遍历
        - 散列表的数据是无序存储的，要输出有序数据，需要先进行排序。
        - 对二叉查找树来说，我们只需要**中序遍历**，就可以在`O(n)` 的时间复杂度内，输出有序的数据序列。
    2. 稳定性
        - 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定
        - 尽管二叉查找树的性能不稳定，但在工程中，我们最常用的**平衡二叉查找树**的性能非常稳定，时间复杂度稳定在 `O(logn)`。
    3. 效率
        - 散列表，因为有**哈希冲突**的存在，这个常量级`O(1)`不一定比 logn 小，所以实际查找速度不一定比 `O(logn)` 快。
        - 加上**哈希函数**的耗时。
    4. 实现复杂度
        - 散列表的构造，需要考虑的东西很多。散列函数的设计、冲突解决办法、扩容、缩容等
        - 平衡二叉查找树只需要考虑**平衡性**这一个问题，而这个问题的解决方法比较成熟、固定。
    5. 空间上考虑
        - 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。
3.  小结
    -   两者存在并不冲突
    -   在实际开发过程中，需要结合具体的需求来选择使用哪一个。
### 课后思考

1.  如果通过编程，求出一棵给定二叉树的确切高度呢？

#### 精选留言

1.  `#拉欧`

>   递归法，根节点高度=max(左子树高度，右子树高度)+1