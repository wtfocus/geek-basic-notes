[TOC]

## 20 | 散列表（下）：为什么散列表和链表经常会一起使用？

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5i4nla1j5j30vq0hs3z3.jpg)

- 有两种数据结构，散列表和链表，经常会放在一起使用。前面章节中，都有哪些地方讲到散列表和链表组合使用吗？
    - LRU 缓存淘汰算法
    -  redis 有序集合中的跳表（改进版的链表），不仅使用跳表，还用到了散列表
    - java 中 LinkedHashMap 也用到散列表和链表
- 今天，我们就来看看，为什么散列表和链表会经常放到一起使用。

### LRU 缓存淘汰算法

- 在链表那一节，我提到，借助散列表，我们可以把 LRU 缓存淘汰算法的时间复杂度降低为 `O(1)`。我们来看看它是怎么做到的。
- 一个缓存系统主要包含下面几个操作：
    - 添加
    - 删除
    - 查找
- 上面三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是`O(n)`。
- 如果**散列表和链表组合**使用，可以将这三个操作的时间复杂度降低到`O(1)`。具体的**组合存储结构**就是下面这个样子。
- ![](http://ww2.sinaimg.cn/large/006tNc79ly1g5ixo0sjdaj30vq0k6jsa.jpg)
- 我们的散列表是通过链表法解决散列冲突的，所以，每个结点会在两条链中。
    - 一个链是常规的**双向链表**
    - 另一个链是散列表中的**拉链**
- **前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。**
- 下面来看看前面讲到的缓存的三个操作，是如何做到时间复杂度是 `O(1)` 的？
    - **查找**
        - 散列表中查找数据的时间复杂度接近`O(1)`，通过散列表，我们可以很快地在缓存中找到一个数据。
        - 当找到数据后，我们还需要将它移动到双向链表的尾部。
    - **删除**
        - 借助散列表，我们可以在`O(1)` 的时间复杂度里找到要删除的结点。
        - 因为我们的链表是双向链表，双向链表可以通过前驱指针`O(1)` 时间复杂度获取前驱结点，所以，删除结点只需要`O(1)`的时间复杂度。
    - **添加**
        - 查看添加的这个数据是否已经在缓存中。
            - 如果已经在其中，需要将其移动到双向链表的尾部。
            - 如果不在其中，还要看缓存是否满。
                - 如果满了，将双向链表头部的结点删除，然后再将数据放到链表尾部。
                - 如果没满，就直接将数据放到链表尾部。
- 整个过程涉及的查找操作都可以通过散列表来完成。其他，如删除，插入都可以在 `O(1)` 的时间复杂度内完成。所以，这三个操作的时间复杂度都是 `O(1)`。

### Redis 有序集合

- 在有序集合中，每个成员对象由两个重要的属性：
    - key 键值
    - score 分值
- 例子
    - 比如一个用户积分排行榜，我们可以通过 id 来查找积分信息，也可以通过积分区间来查找用户 id 或姓名信息。
- redis 有序集合操作：
    - 添加成员对象
    - 按键值删除一个成员对象
    - 按键值查找一个成员对象
    - 按分值区间来查找数据
    - 按分值从小到大排序成员变量
- 按照键值构建一个散列表，这样按 key 来删除、查找一个成员对象的时间复杂度就变成了 `O(1)`。同时，借助跳表结构，其他操作也非常高效。

### Java LinkedHashMap

- 在 Java 中，HashMap 底层通过散列表来实现的。

- 来看一段代码，

- ```java
    HashMap<Integer, Integer> m = new LinkedHashMap<>();
    m.put(3, 11);
    m.put(1, 12);
    m.put(5, 23);
    m.put(2, 22);
    
    for (Map.Entry e : m.entrySet()) {
      System.out.println(e.getKey());
    }
    
    ```

- 上面的代码会按照数据插入的顺序依次打印。

- 散列表中数据是经过散列函数打乱后无规律存储的，这里是如何实现按照数据插入顺序来遍历打印的呢？

- LinkedHashMap 是通过散列表和链表组合在一起实现的。实际上，它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。看下面 这段代码。

- ```java
    // 10 是初始大小，0.75 是装载因子，true 是表示按照访问时间排序
    HashMap<Integer, Integer> m = new LinkedHashMap<>(10, 0.75f, true);
    m.put(3, 11);
    m.put(1, 12);
    m.put(5, 23);
    m.put(2, 22);
    
    m.put(3, 26);
    m.get(5);
    
    for (Map.Entry e : m.entrySet()) {
      System.out.println(e.getKey());
    }
    
    ```

- 这段代码打印结果是 1，2，3，5。为什么会按照这样的顺序来打印？

    - 每次调用 put() 函数，往 LinkedHashMap 中添加数据的时候，都会将数据添加到链表的尾部，所以，在前四个操作完成后，链表中数据是下面这样：
    - ![](http://ww1.sinaimg.cn/large/006tNc79ly1g5ja3qlppnj30vq08p3yj.jpg)
    - 第 8 行代码中，再次将值为 3 的数据放入到 LinkedHashMap 的时候，
        - 会先查找这个键值是否已经有了，
        - 然后，将已经存在的 (3, 11)删除，
        - 再将新的 (3, 26) 放到链表尾部。
    - 这时，链表中数据如下：
    - ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5ja6mh1j4j30vq08naa3.jpg)
    - 第 9 行访问到 key 为 5 的数据的时候，我们将被访问到的数据移动到链表尾部。这时，链表中数据是下面这样的
    - ![](http://ww2.sinaimg.cn/large/006tNc79ly1g5ja8g2s7pj30vq09m74b.jpg)

- **总结**

    - **LinkedHashMap是通过双向链表和散列表这两种数据结构组合实现的。**
    - **LinkedHashMap 中 Linked 实际上是指的是双向链表，并非指定用链表法解决散列冲突。**

### 解答开篇 & 内容小结

- 为什么散列表和链表经常一块使用？
    - 散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是，散列表中的数据都是通过散列函数打乱后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将数据拷贝到数组中，然后排序，再遍历。
    - 因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这种问题，我们将散列表和链表（或跳表）结合在一起使用。

### 课后思考

1. 如果把今天讲的几个例子里的双向链表改成单链表，是否还能正常工作？为什么呢？
2. 假设猎聘网有 10万个猎头，每个猎头都可以通过做任务来积累积分，然后通过积分来下载简历。那我们如何在内存中存储这 10 万个猎头 ID 和积分信息，让他支持如下几个操作。
    1. 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息。
    2. 查找积分在某个区间的猎头 ID 列表。
    3. 查找按照积分从小到大排名在第 x 位到第 y 位间的猎头 ID 列表。

#### 精选一

- 散列表、链表、跳表混合使用，是为了结合数据和链表的优势，规避它们的不足。
- 我们可以得到数据结构和算法的重要性排行榜： 连续空间>时间>碎片空间。

#### 精选二

1. 在删除一个元素时，虽然能`O(1)`找到目标结点，但是要删除该结点需要拿到前一个结点的指针，遍历到前一个结点复杂度会变为 `O(n)` ，所以用双链表实现比较合适。
2. 以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。
    1. ID 在散列表中，所以可以 `O(1)` 查找这个猎头。
    2. 积分以跳表存储，跳表支持区间查询。
    3. 这点根据目前学习暂时无法实现。