[TOC]

## 48 | B+ 树： MySQL 数据库索引是如何实现的？

- **数据库的索引是如何实现的呢？底层使用的是什么数据结构和算法呢？**

### 算法解析

#### 1.  解决问题的前提是定义清楚问题

- **通过对一些模糊的需求进行假设，来限定要解决的问题的范围。**
- 这里假设我们要解决的问题，只包含如下两个常用的需求：
    - 根据某个值查找数据，如 `select * from user where id = 1234;`
    - 根据区间值来查找某些数据，如 `select * from user where id > 1234 and id < 2345;`
- 这里我们着重考虑**性能方面**的需求，性能方法的需求，我们主要考察时间和空间两个方面，也就是**执行效率和存储空间**。
    - 在执行效率方面，我们希望通过索引，查询的效率尽可能的高。
    - 在存储空间方面，我们希望索引不会消耗太多的内存空间。

#### 2. 尝试用学过的数据结构解决这个问题

- 支持快速查询、插入等操作的动态数据结构，我们已经学过散列表、平衡二叉查找树、跳表。
- **散列表**
    - 查询性能很好，时间复杂度是 O(1)。
    - 但是，散列表不能支持按区间快速查找数据。所以，散列表不能满足我们的需求。
- **平衡二叉查找树**
    - 查询性能也很高，时间复杂度是 O(logn)。
    - 对树进行中序遍历，我们还可以得到一个从小到大的有序数据序列。
    - 但这仍然不足以支持按区间快速查找数据。
- **跳表**
    - 跳表是在链表之上加上多层索引构成的。
    - 它支持快速插入、查找、删除数据，对应的时间复杂度是 O(logn)。
    - 并且，跳表也支持按照区间快速查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后，从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。
    - ![img](https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg)
- 这样看来，跳表是可以解决这个问题。
- 实际上，数据索引所用到的数据结构跟跳表非常相似，叫 B+ 树。不过它是通过二叉查找树演化过来的，是非跳表。

#### 3. 改造二叉查找树来解决这个问题

- 改造：
    - 树的节点中并不存储数据本身，而是只是作为索引。
    - 把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。

- 改造后的二叉树，如下图：

    - ![img](https://static001.geekbang.org/resource/image/25/f4/25700c1dc28ce094eed3ffac394531f4.jpg)

- 改造后，如果我们要查找某个区间数据。

    - 我们只需拿区间的起始值，在树中进行查找，当查找到某个叶子节点后，我们再顺着链表往后遍历，直到链表中结点数据值大于区间的终止值为止。
    - ![img](https://static001.geekbang.org/resource/image/1c/cc/1cf179c03c702a6ef5b9336f5b1eaecc.jpg)

- 如果数据量太大，那内存占用就会非常多。那如何解决这个索引占用太多内存的问题呢？

    - **我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。**
    - 这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。

- 二叉查找树，经过改造后，支持区间查找的功能就实现了。不过为了节省内存，如果把树存储在硬盘中，那么每个节点的读取，都对应一次硬盘 IO 操作。**树的高度就等于每次查询数据时磁盘 IO 操作的次数。**

- 比起内存读写，磁盘 IO 操作非常耗时，所以我们优化的重点就尽量减少磁盘 IO 操作。也就是降低树的高度。**那如何降低树的高度呢？**

- 如下图中，我们把二叉树变为5 叉树，那树的高度就变小了（磁盘 IO 变少了），查找数据效率也就提高了。

    - ![img](https://static001.geekbang.org/resource/image/69/59/69d4c48c1257dcb7dd6077d961b86259.jpg)
    - ![img](https://static001.geekbang.org/resource/image/76/cc/769687f57190a826a8f6f82793491ccc.jpg)

- **如果我们将 m 叉树实现 B+ 树索引，用代码实现出来**，就是下面这样子（假设我们给 int 类型的数据库字段添加索引，所以代码中 keywords 是int 类型的）

    - ```java
        /**
         * 这是 B+ 树非叶子节点的定义。
         *
         * 假设 keywords=[3, 5, 8, 10]
         * 4 个键值将数据分为 5 个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF)
         * 5 个区间分别对应：children[0]...children[4]
         *
         * m 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：
         * PAGE_SIZE = (m-1)*4[keywordss 大小]+m*8[children 大小]
         */
        public class BPlusTreeNode {
          public static int m = 5; // 5 叉树
          public int[] keywords = new int[m-1]; // 键值，用来划分数据区间
          public BPlusTreeNode[] children = new BPlusTreeNode[m];// 保存子节点指针
        }
        
        /**
         * 这是 B+ 树中叶子节点的定义。
         *
         * B+ 树中的叶子节点跟内部结点是不一样的,
         * 叶子节点存储的是值，而非区间。
         * 这个定义里，每个叶子节点存储 3 个数据行的键值及地址信息。
         *
         * k 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：
         * PAGE_SIZE = k*4[keyw.. 大小]+k*8[dataAd.. 大小]+8[prev 大小]+8[next 大小]
         */
        public class BPlusTreeLeafNode {
          public static int k = 3;
          public int[] keywords = new int[k]; // 数据的键值
          public long[] dataAddress = new long[k]; // 数据地址
        
          public BPlusTreeLeafNode prev; // 这个结点在链表中的前驱结点
          public BPlusTreeLeafNode next; // 这个结点在链表中的后继结点
        }
        
        ```

- 对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小，那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？

    - 不管是内存中，还是磁盘中的数据。对操作系统来说，都是按页（一页大小通常为 4KB，这个值可以通过 getconfig PAGE_SIZE 来查看）来读取的，一次会读取一页的数据。如果一次读取量超过一页大小，就会触发多次 IO 操作。**所以我们在选择 m 大小时，要尽量让每个节点的大小等于一个页的大小**。这样，读取一个节点，只需要一次磁盘 IO 操作。
    - ![img](https://static001.geekbang.org/resource/image/ea/30/ea4472fd7bb7fa948532c8c8ba334430.jpg)

- 索引有利有弊，它也会让写入数据的效率下降。这是为什么呢？

    - **数据写入的过程，会涉及索引的更新。（变慢的主要原因）**

- **对于一个 B+ 树来说，m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。**如果某些节点的子节点个数超过 m，这个节点的大小超过一个页的大小，读取这样一个节点，就会导致多次 IO 操作。那我们该如何解决这个问题呢？

    - 处理思路并不复杂。我们只需要**将这个节点分裂成两个节点**。节点分裂后，其上层父节点的子节点个数就有可能超过 m 个。不过这也没关系 ，我们可以用同样的方法，将父节点分裂成两个节点。**这种级联反应会从下往上，一直影响到根节点。**

- 上面这个分裂过程可以看如下图理解：

    - ![img](https://static001.geekbang.org/resource/image/18/e0/1800bc80e1e05b32a042ff6873e6c2e0.jpg)

- 正是因为要时刻保证 B+ 树索引是一个 m 叉树，所以索引的存在会导致数据库写入速度降低。（包括删除也会变慢），这是为什么呢？

    - 我们在删除某个数据的时候，也要对应的更新索引的节点。这个处理思路有点类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些结点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。
    - 我们可以设置一个阈值。在 B+ 树中，这个阈值等于 m/2。如果某个节点的子节点个数小于 m/2，我们就将它跟相邻的兄弟节点合并。不过合并后结点的子节点个数有可能会超过 m 。针对这种情况，我们可以借助插入数据时的处理方法，再分裂节点。
    - 观察如下图，来理解。
    - ![img](https://static001.geekbang.org/resource/image/17/18/1730e34450dad29f062e76536622c918.jpg)

- 数据库索引以及 B+ 树的由来，到此就讲完了。它与跳表非常类似。

### 总结引申

- 今天，我们讲解了数据库索引实现，依赖的底层数据结构，B+树。
    - 它通过存储在磁盘的多叉树结构，做到了时间、空间的平衡，既保证了执行效率，又节省了内存。
- B+ 树的特点：
    1. 每个节点中子节点的个数不超过 m，也不能小于 m/2。
    2. 根节点的子节点个数可以不超过 m/2，这是一个例外。
    3. m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表。
    4. 通过链表将叶子节点串联在一起，这样可以方便按区间查找。
    5. 一般情况，要节点会被存储在内存中，其他节点存储在磁盘中。
- B- 树，其实就是 B 树。“-” 并不是相对 B+ 树中的 “+”。而只是 “B-Tree” 的一个连接符。
- B 树，实际上是低阶版的 B+ 树，或者说， B+ 是 B 树的改进版。
- B 树跟 B+ 树的不同点主要集中在几个地方：
    - B+ 树中节点不存储数据，只是索引，而 B 树中的节点存储数据。
    - B 树中的叶子节点并不需要链表来串联。
- 也就是说，B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树。

### 课后思考

1. B+ 树中，将叶子节点串起来的链表，是单链表还是双向链表？为什么？
2. 我们对平衡二叉查找树进行改造，将叶子节点串在链表中，就支持了按区间来查找数据。我们在`散列表（下）`讲到，散列表也经常跟链表一块使用，如果我们把散列表中的结点，也用链表串起来，能否支持按照区间查找数据呢？

