[toc]

## 04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度


### 最好、最坏情况时间复杂度

1.  最好情况时间复杂度就是，在**最理想的情况下**，执行这段代码的时间复杂度。
2.  最坏情况时间复杂度就是，**在最糟糕的情况下**，执行这段代码的时间复杂度。

### 平均情况时间复杂度

1.  平均时间复杂度**如何分析**呢？
2.  查找的变量 x 在数组中的位置，有 **n+1** 种情况：**在数组的 0～n-1 位置中和不在数组中**。
    -   ![img](imgs/d889a358b8eccc5bbb90fc16e327a22f.jpg)
    -   公式简化后，得到平均时间复杂度就是 **O(n)**。
3.  引入概率后，假设在数组中与不在数组中的概率都为 **1/2**。根据概率乘法法则，要查找的数据在 0～n-1 中任意位置的概率就是 **1/(2n)**。
    -   ![img](imgs/36c0aabdac69032f8a43368f5e90c67f.jpg)
    -   这个值就是概率论中的**加权平均值**，也叫**期望值**，所以平均时间复杂度全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**。
    -   用大 O 表示法来表示，这段代码的加权平均时间复杂度仍然是 `O(n)`。

### 均摊时间复杂度

1.  **均摊时间复杂度**，分析方法：**摊还分析**。
2.  那**如何使用**摊还分析法来分析算法的均摊时间复杂度呢？
    -   在数组中插入数据的这个例子。
    -   均摊分析的**大致思路**：每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以，**把耗时多的那次操作均摊到接下来 n-1 次耗时少的操作上，均摊下来，**这一组连续的操作的均摊时间复杂度就是 O(1)。
3.  应用**场景**
    -   对一个数据结构进行一组连续操作中，**大部分**情况下，时间复杂度都很低，只有**个别**情况下时间复杂度较高，而且这些操作间都存在**前后连贯**的时序关系。
    -   这个时候，我们就可以将这一组操作放在一块儿分析，看是否将较高时间复杂度那次操作的耗时，**平摊**到其他那些时间复杂度比较低的操作上。
    -   而且，在能够应用均摊复杂度分析的场合，一般均摊时间复杂度**就等于最好情况时间复杂度**
4.  **均摊时间复杂度就是一咱特殊的平均时间复杂度。**

### 小结

1.  几个复杂度分析相关的概念：最好情况时间复杂、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度。
2.  之所以引入这几个复杂度的概念，是因为，**同一段代码，在不同输入**的情况下，**复杂度量级**有可能是不一样的。

## 课后思考

+ 分析一下下面这个 add() 函数的时间复杂度。

```C++
// 全局变量，大小为 10 的数组 array，长度 len，下标 i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个 2 倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来 array 数组中的数据依次 copy 到 new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array 复制给 array，array 现在大小就是 2 倍 len 了
     array = new_array;
     len = 2 * len;
   }
   // 将 element 放到下标为 i 的位置，下标 i 加一
   array[i] = element;
   ++i;
}
```

### 精选留言

1.  #Alvin

    >   老师讲的很好，练习题最好是O(1)，最差是O(n), 均摊是O(1)。
    >
    >   
    >
    >   看到好多人纠结于清空数组的问题: 对于可反复读写的存储空间，使用者认为它是空的它就是空的。如果你定义清空是全部重写为0或者某个值，那也可以！但是老师举的例子完全没必要啊！写某个值和写任意值在这里有区别吗，使用值只关心要存的新值！所以老师的例子，清空把下标指到第一个位置就可以了！

2.  #好吃二师兄

    >   最好是O(1),最坏是O(n),平均平摊是O(1).
    >
    >   
    >
    >
    >   不要纠结add和insert在哪儿被调用了。。。代码都写出来反而不好看。
    >
    >   
    >
    >   个人体会: 平均和平摊基本就是一个概念，平摊是特殊的平均。在分析时间复杂度是O(1)还是O(n)的时候最简单就是凭感觉，，，，，，，，出现O(1)的次数远大于出现O(n)出现的次数，那么平均平摊时间复杂度就是O(1)。。。。

3.  #姜威

    >   总结
    >
    >   
    >
    >   一、复杂度分析的4个概念
    >
    >   1.最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。
    >
    >   2.最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。
    >
    >   3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。
    >
    >   4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。
    >
    >   
    >
    >   二、为什么要引入这4个概念？
    >
    >   1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。
    >
    >   2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。
    >
    >   
    >
    >   三、如何分析平均、均摊时间复杂度？
    >
    >   1.平均时间复杂度
    >
    >   代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。
    >
    >   2.均摊时间复杂度
    >
    >   两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。