[TOC]

## 27 | 递归树： 如何借助树来求解递归算法的时间复杂度？

![img](https://static001.geekbang.org/resource/image/2f/6d/2fde598f081f84187695fbf1937c446d.jpg)

- 今天我们学习一种方法：**借助递归树来分析递归算法的时间复杂度。**

### 递归树与时间复杂度分析

- 我们把递归分解的过程画成图，它其实就是一棵树 —— **递归树**。
    - 这里画了一个斐波那契数列的递归树：
    - ![img](https://static001.geekbang.org/resource/image/1d/a3/1d9648b7f43e430473d76d24803159a3.jpg)
- **如何用递归树来求解时间复杂度**
    - 这里我们借助归并排序来看看，如何分析递归代码的时间复杂度。
    - 归并排序画成递归树，如下：
    - ![img](https://static001.geekbang.org/resource/image/c6/d0/c66bfc3d02d3b7b8f64c208bf4c948d0.jpg)
    - 归并算法中比较耗时的是归并操作。从图中看出，每一层的归并操作消耗的时间总和是一样的。
    - 我们把每一层归并操作消耗的时间记作 n。高度记作 h。就可以得到总的时间复杂度 **`O(n*h)`。**
    - 从归并排序的原理和递归树，可以看出，归并排序递归树是一棵满二叉树。**满二叉树的高度大约是 $log_2n$。**所以归并排序递归实现的时间复杂度是 **`O(nlogn)`。**

### 实战一：分析快速排序时间复杂度

- 递推公式分析法
    - 快排最好情况下，每次分区都能一分为二，这时用的递推公式 `T(n)=2T(n/2) + n`
    - 平均情况下，每次分区后，两个分区比例为`1:k`。当 k=9 时，递推公式就写成 `T(n)= T(n/10) + T(9n/10) + n`
- **递归树分析法**
    - 递归树如下
    - ![img](https://static001.geekbang.org/resource/image/44/43/44972a3531dae0b7a0ccc935bc13f243.jpg)
    - 每一层分区操作所遍历的数据个数之和是 n。递归树高度设为 h。**时间复杂度就是 `O(n*h)**`
    - 快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 1/10，最长路径每次都乘以 9/10。通过计算，我们可以得到，从根节点到叶子节点的最短路径是 log<sub>10</sub>n​，最长路径是 log<sub>10/9</sub>n。
    - ![img](https://static001.geekbang.org/resource/image/7c/ed/7cea8607f0d92a901f3152341830d6ed.jpg)
    - 所以，遍历数据的个数总和就介于  nlog<sub>10</sub>n 和 nlog<sub>10/9</sub>n 之间。根据复杂度大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以，**当分区大小比例是 `1:9`时，快速排序的时间复杂度仍然是 O(nlogn)。**
    - 如果 k=99，也就是说，每次分区极其不平均，两个区间大小是 1:99。尽管底数变了，但是，时间复杂度也仍然是 `O(nlogn)`
- 小结
    -   对于 k 等于 9， 99 甚至 999， 9999……，**只要 k 的值不随 n 变化，是一个事先确定的常量，那快排的时间复杂度就是 `O(nlogn)`。**所以，从概率论的角度来说，快排的平均时间复杂度就是 `O(nlogn)`。

### 实战二：分析斐波那契数列的时间复杂度

-   斐波那契数列代码：

    -   ```C
        int f(int n) {
          if (n == 1) return 1;
          if (n == 2) return 2;
          return f(n-1) + f(n-2);
        }
        
        ```

-   用递归树来分析上面递归代码的时间复杂度：

    -   ![img](https://static001.geekbang.org/resource/image/9c/ce/9ccbce1a70c7e2def52701dcf176a4ce.jpg)

-   这棵树的高度是多少呢？

    -   `f(n)` 分解为 `f(n-1)` 和 `f(n-2)`，每次数据规模都是 -1或 -2，叶子节点的数据规模是 1 或 2。
    -   所以，从根节点到叶子节点，每条路径是长短不一的。**如果每次都是 -1，那最长路径大约是 n。如果每次都是 -2，那最短路径大约是 n/2。**

-   每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 2<sup>2</sup>。依次类推，**第 k 层的时间消耗就是 2<sup>k-1</sup>，**那整个算法的总的时间消耗就是每一层时间消耗之和。

-   **如果路径长度都为 n，那这个总和就是 2<sup>n</sup> - 1。**

    -   ![img](https://static001.geekbang.org/resource/image/86/1f/86d301fc5fa3088383fa5b45f01e4d1f.jpg)

-   **如果路径长度都是 n/2，那整个算法的总的时间消耗就是 2<sup>n/2</sup> - 1。**

    -   ![img](https://static001.geekbang.org/resource/image/55/d4/55fcb1570dfa09e457cdb93ba58777d4.jpg)

-   小结

    -   所以，**这个算法的时间复杂度就介于 O(2<sup>n</sup>) 和 O(<sup>n/2</sup>) 之间。**
    -   虽然这样得到的结果还不够精确，只是一个范围，但是，我们基本上知道了上面算法的时间复杂度是指数级的，非常高。

### 实战三：分析全排列的时间复杂度

-   我们再来看个稍微复杂的。

    -   “如何把 n 个数据的所有排列都找出来”，这就是**全排列**的问题。

-   例：

    -   如 1，2，3 这样 3 个数据，有下面几种不同的排列：

    -   ```
        1, 2, 3
        1, 3, 2
        2, 1, 3
        2, 3, 1
        3, 1, 2
        3, 2, 1
        ```

-   如何编程打印一组数据的所有排列呢？这里可以用**递归**来实现。

    -   如果我们确定了最后一位数据，那就变成了求解剩下 n-1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个 “n-1 个数据的排列”的子问题。

    -   递推公式

        -   ```
            假设数组中存储的是 1，2， 3...n。
                    
            f(1,2,...n) = {最后一位是 1, f(n-1)} + {最后一位是 2, f(n-1)} +...+{最后一位是 n, f(n-1)}。
            
            ```

    -   递推公式改写成代码

        -   ```java
            // 调用方式：
            // int[]a = a={1, 2, 3, 4}; printPermutations(a, 4, 4);
            // k 表示要处理的子数组的数据个数
            public void printPermutations(int[] data, int n, int k) {
              if (k == 1) {
                for (int i = 0; i < n; ++i) {
                  System.out.print(data[i] + " ");
                }
                System.out.println();
              }
            
              for (int i = 0; i < k; ++i) {
                int tmp = data[i];
                data[i] = data[k-1];
                data[k-1] = tmp;
            
                printPermutations(data, n, k - 1);
            
                tmp = data[i];
                data[i] = data[k-1];
                data[k-1] = tmp;
              }
            }
            
            ```

-   借助递归树，轻松分析出这个代码的时间复杂度。

    -   现在的递归树已经不是标准的二叉树了。
    -   ![img](https://static001.geekbang.org/resource/image/82/9b/82f40bed489cf29b14192b44decf059b.jpg)
    -   第一层分解有 n 次交换操作，
    -   第二层有 n 个节点，每个节点分解需要 n - 1 次交换，所以第二层总的交换次数是 n * (n-1)。
    -   第三层有 n * (n-1)个节点，每个节点分解需要 n - 2 次交换，所以第三层总的交换次数是 n * (n-1) * (n-2)
    -   ……
    -   以此类推，第 k 层总的交换次数就是 n * (n-1) * (n-2) * ... * (n-k+1)。最后一层的交换次数就是 n * (n-1) * (n-2) * ... * 2 * 1。每一层的交换次数之和就是总的交换次数。

-   小结

    -   我们看最后一个数， n * (n-1) * (n-2) * ... * 2 * 1 等于 n!，而前面的 n-1 个数都小于最后一个数，所以，总和肯定小于 n * n!，也就是说全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n*n!)，虽然，我们没法知道非常精确的时间复杂度，但是，这样一个范围已经让我们知道，全排列的时间复杂度是非常高的。
    -   这里稍微说下，掌握分析的方法很重要，思路是重点，不要纠结于精确的时间复杂度到底是多少。

### 内容小结

-   今天，我们用递归树分析了递归代码的时间复杂度。加上我们在排序那一节讲到的递归公式时间复杂度方法，我们现在已经学习了两种递归代码的时间复杂度分析方法了。
-   有些代码比较适合用递推公式来分析，如，归并排序的时间复杂度、快速排序的最好情况时间复杂度。
-   有些代码比较适合用递归树来分析，如，快速排序的平均时间复杂度。
-   而有些可能两个都不怎么适合使用，如，二叉树的递归前中后序遍历。
-   在我们平时工作学习中，要多实战、多分析、只有这样，面对任何分析的时间复杂度分析，你才能做到游刃有余，毫不畏惧。

### 课后思考

1.  1 个细胞的生命周期是 3 小时间，1 个小时分裂一次。求 n 小时后，容器内有多少个细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。

