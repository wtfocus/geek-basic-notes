[TOC]

## 30 | 图的表示：如何存储微博、微信等社交网络中的好友关系？

-   **如何存储微博、微信这些社交网络的好友关系吗？**
-   今天，我们聚焦在图的**存储**这一方面。

### 如何理解“图”

-   之前，我们讲了树这种非线性表数据结构，今天，我们讲另一咱非线性表数据结构——**图（Graph）**。
-   **顶点（vertex）**
    -   图中的元素
-   **边（edge）**
    -   一个顶点可以与任意顶点建立关系。这种关系叫边。
    -   ![img](https://static001.geekbang.org/resource/image/df/af/df85dc345a9726cab0338e68982fd1af.jpg)
-   **度（degree）**
    -   跟顶点相连接的边的条数。
-   **有向图**
    -   边有方向的图
    -   ![img](https://static001.geekbang.org/resource/image/c3/96/c31759a37d8a8719841f347bd479b796.jpg)
    -   **入度（in-degree）**
        -   有多少条边指向这个顶点的。
    -   **出度（out-degree）**
        -   有多少条边是以这个顶点为起点指向其他顶点的。
-   **无向图**
    -   边没有方向的图
-   **带权图（weighted graph）**
    -   每条边都有一个权重（weight）。
    -   ![img](https://static001.geekbang.org/resource/image/55/e8/55d7e4806dc47950ae098d959b03ace8.jpg)

### 邻接矩阵存储方法

-   图最直观的一种存储方法。
-   实现原理
    -   邻接矩阵的底层依赖一个二维数组。
    -   无向图
        -   如果顶点 i 与顶点 j 之间有边，我们就将 `A[i][j]` 和 `A[j][i]`标记为 1。
    -   有向图
        -   如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 `A[i][j]` 标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 `A[j][i]` 标记为 1。
    -   带权图
        -   数组中就存储相应的权重
    -   ![img](https://static001.geekbang.org/resource/image/62/d2/625e7493b5470e774b5aa91fb4fdb9d2.jpg)
-   缺点
    -   用邻接矩阵来表示一个图，虽然简单、直观，但是，比较浪费存储空间。为什么这么说呢？
    -   对于无向图
        -   如果 `A[i][j]` 等于 1，那 `A[j][i]` 也肯定等于 1。
        -   实际上，我们只存储一个就可以了。另外一半白白浪费掉了。
    -   如果，我们存储的是**稀疏图（Sparse Matrix）**，也就是说，顶点很多，但，每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。
-   优点
    -   邻接矩阵的存储方式简单、直观，因为基于数组，所以在获取两个顶点的关系时，就非常高效。
    -   方便计算。
        -   在用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。
        -   [Floy-Wareshall 算法](https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95) ，就是利用矩阵循环相乘若干将得到结果。

### 邻接表存储方法

-   实现原理
    -   ![img](https://static001.geekbang.org/resource/image/03/94/039bc254b97bd11670cdc4bf2a8e1394.jpg)
    -   邻接表是不是有点像散列表？**每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。**
    -   上图中画的是一个**有向图**的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。
    -   对于**无向图**，也类似，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。
-   设计思想
    -   邻接矩阵存储起来比较浪费空间，但是，使用起来比较节省时间。
    -   相反，邻接表存储起来比较节省空间，但是，使用起来就比较耗时间。
    -   分析
        -   如果上图，如果，我们要确定是否存储一条从顶点 2 到顶点 4 的边，那我们就遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。
        -   而且，链表的存储方式对缓存不友好 。
        -   所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点间的关系就没那么高效了。

### 解答开篇

-   如何存储微博、微信等社交网络的好友关系？
    -   在这个问题上，两者的解决思路差不多，所以，我只拿微博来讲解。
    -   数据结构是为算法来服务的，具体选择哪种存储方法，**与期望支持的操作有关系。**假设，我们需要支持下面这样几个操作：
        -   判断用户 A 是否关注了用户 B。
        -   判断用户 A 是否是用户 B 的粉丝。
        -   用户 A 关注用户 B
        -   用户 A 取消关注用户 B
        -   根据用户名称的首字母排序，分页获取用户的粉丝列表。
        -   根据用户名称的首字母排序，分页获取用户的关注列表。
    -   因为，社交网络是一张**稀疏图**，使用邻接矩阵存储比较浪费存储空间。所以，这里我们采用邻接表来存储。
    -   不用，用邻接表来存储这种有向图是不够的。我们查找某个用户关注了哪些用户容易，但是，**如果要想知道某个用户被哪些用户关注了，也就是用户的粉丝列表，是非常困难的。**
    -   某于此，我们需要一个**逆邻接表**。
        -   **邻接表中存储了用户的关注关系**
        -   **逆邻接表中存储的是用户的被关注关系**
        -   ![img](https://static001.geekbang.org/resource/image/50/a1/501440bcffdcf4e6f9a5ca1117e990a1.jpg)
    -   基础邻接表不适合快速判断两个用户是否是关注与被关注的关系，所以，我们选择改进版本，**将邻接表中的链表改为支持快速查找的动态数据结构**。
        -   因为，我们需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或关注列表，用**跳表**这种结构再合适不过了。
        -   这是因为，跳表插入、删除、查找都非常高效。时间复杂度都是 O(logn)，空间复杂度稍高，是 O(n)。最重要一点，跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，就非常高效。
    -   对于规模的数据，我们可以将整个关系存储在内存中，上面解决思路是没问题的。但是，如果像微博那样有上亿用户，数据规模太大，我们就无法存储在内存中了，这个时候该怎么办呢？
        -   方法一，**通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。**
        -   如下图
            -   机器1 上存储顶点 1，2，3 的邻接表，
            -   机器 2 上存储顶点 4，5，6 的邻接表，
            -   逆邻接表的处理方式也一样。
            -   ![img](https://static001.geekbang.org/resource/image/08/2f/08e4f4330a1d88e9fec94b0f2d1bbe2f.jpg)
        -   当查询顶点与顶点关系的时候，我们就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找。
        -   方法二， **利用外部存储（如硬盘）**，因为外部存储空间要比内在宽裕很多。数据库是我们经常用来持久化存储关系数据的，所以，这里介绍一种数据库的存储方式。
            -   我用下面这张表来存储这样一个图。为了高效地支持前面定义的操作，我们可以在表上建立一个索引，如，第一列、第二列都建立索引。
            -   ![img](https://static001.geekbang.org/resource/image/73/8f/7339595c631660dc87559bec2ddf928f.jpg)

### 内容小结

-   我们今天学习了图，这种非线性表数据结构。
-   概念理解
    -   无向图
    -   有向图
    -   带权图
    -   顶点
    -   边
    -   度
    -   入度
    -   出度
-   图的两个主要存储方式
    -   邻接矩阵
    -   邻接表
-   邻接矩阵
    -   缺点
        -   比较浪费空间
    -   优点
        -   查询效率高
        -   方便矩阵运算
-   邻接表
    -   优点
        -   节省存储空间
    -   缺点
        -   链表不方便查找，查找效率没有邻接矩阵存储方式高
    -   升级版
        -   将链表换成更加高效的动态数据结构，如，平衡二叉查找树、跳表、散列表

### 课后思考

1.  关于开篇思考题，我们只讲了微博这种有向图的解决思路，那像微信这种无向图，应该怎么存储呢？

2.  关于图这种数据结构，你还能想到其他生活中或工作中的例子吗？

