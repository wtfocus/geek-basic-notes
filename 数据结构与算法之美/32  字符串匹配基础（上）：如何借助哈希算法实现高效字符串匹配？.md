[TOC]

## 32 | 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？

-   今天，讲两个算法BF 和 RK。RK 算法是 BF 算法的改进。
-   **那 RK 算法是如何借助哈希算法来实现高效的字符串匹配的呢？**

### BF 算法

-   BF（Brute Force，暴力匹配算法， 也叫朴素匹配算法）
-   概念
    -   **主串**
    -   **模式串**
-   算法思想
    -   **我们在主串中，检查起始位置分别是 0、1、2……n-m 的 n-m+1 个子串，看有没有跟模式串匹配的。**
-   例子
    -   ![img](https://static001.geekbang.org/resource/image/f3/a2/f36fed972a5bdc75331d59c36eb15aa2.jpg)
    -   理论上，**BF 算法时间复杂度很高，是 O(n*m)，但，在实际开发中，它却是一个比较常用的字符串匹配算法。**为什么这么说呢？
        -   第一，
            -   在实际软件开发中，大部分情况下，模式串和主串的长度不会太长。
            -   在匹配过程中，当中途遇到不能匹配的字符的时候，就可以停止了，不需要再把 m 个字符都对比一下。
        -   第二，
            -   朴素字符串匹配算法思想简单，代码实现也非常简单。

### RK 算法

-   背景
    -   BF 算法的时间复杂度比较高，是 O(n*m)。我们对相互的字符串匹配算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。
-   RK 算法思路
    -   我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。
    -   如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（暂不考虑哈希冲突，后面会讲到）。
    -   因为，哈希值是一个数字，数字间比较是否相等是非常快速的，所以，模式串和子串比较的效率就提高了。
-   思考
    -   通过哈希算法计算的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了。但是，算法整体的效率并没有提高。
    -   那有没有方法，可以提高哈希算法计算子串哈希值的效率呢？
-   优化思路
    -   **假设，我们要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。**
-   实现
    -   比如，要处理的字符串只包含 a~z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a~z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 就表示 25。
    -   十进制和二十六进制计算方法
    -   ![img](https://static001.geekbang.org/resource/image/d5/04/d5c1cb11d9fc97d0b28513ba7495ab04.jpg)
-   思考
    -   这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。如下图：
        -   ![img](https://static001.geekbang.org/resource/image/f9/f5/f99c16f2f899d19935567102c59661f5.jpg)
        -   这里，我们很容易就能得出这样的规律：
            -   相邻两个子串 s[i-1] 和 s[i] （i 表示子串在主串中的起始位置，子串的长度都为 m）,对应的哈希值计算有次交集。
            -   也就是说，我们通过 s[i-1] 的哈希值很快就能求出 s[i] 的哈希值。
        -   用公式表示这种规律的话，如下
            -   ![img](https://static001.geekbang.org/resource/image/f2/ee/f298f1e5c93b205345b9cd6d9c53fbee.jpg)
        -   注意
            -   26<sup>(m-1)</sup> 这部分的计算，我们可以通过查表的方法来提高效率。
            -   我们事先先计算好 26<sup>0</sup>、26<sup>1</sup>、26<sup>2</sup>……26<sup>(m-1)</sup>，并且，存储在一个长度为 m 的数组中，公式的“次方”，就是对应数组的下标。
            -   当我们需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。
            -   ![img](https://static001.geekbang.org/resource/image/22/2f/224b899c6e82ec54594e2683acc4552f.jpg)
-   RK 算法的时间复杂度
    -   整个  RK 算法包含两个部分，
        -   计算子串哈希值
            -   通过设计特殊的哈希算法，只需要扫描一遍主串，就能计算出所有子串的哈希值。所以这部分的时间复杂度是 O(n)。
        -   与子串哈希值之间的比较
            -   比较的时间复杂度是 O(n)，总共需要比较 n-m+1 个子串的哈希值。所以，这部分的时间复杂度也是 O(n) 。所以，RK 算法整体的时间复杂度就是 O(n)。
-   散列冲突（哈希冲突）
    -   问题
        -   如果模式串很长，通过上面的哈希计算计算得到的哈希值就可能很大。如果超出了计算机中整型数据可以表示的范围，那该如何解决呢？
        -   之前，我们只需要比较一下模式串和子串的哈希值 ，如果两个值相等，那就这个子串就一定可以匹配模式串。但，当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但两者本身并不匹配。
    -   解决
        -   当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只需要再对比一下子串和模式串本身就好了。
        -   当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，那就不需要对比子串和模式串本身了。
    -   思考
        -   哈希算法的冲突概率要相对控制得低一点，如果存在大量的冲突，就会导致 RK 算法的时间复杂度退化，效率下降。极端情况下，时间复杂度会退化成 O(n*m)。

### 解答开篇 & 内容小结

-   今天，我们讲了两种字符串匹配算法：
    -   BF 算法
    -   RK 算法
-   BF 算法
    -   最简单、粗暴的字符串匹配算法，
    -   实现思路
        -   拿模式串与主串中所有子串匹配，看是否有能匹配的子串。
    -   时间复杂度
        -   O(n*m)
    -   对于处理小规模的字符串匹配很好用。
-   RK 算法
    -   思路
        -   借助哈希算法对 BF 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较时间。
    -   时间复杂度
        -   理想情况下
            -   O(n)
        -   存在冲突的情况下，时间复杂度可能会退化。极端情况下，
            -   O(n*m)

### 课后思考

1.  假设，在下面这样的一个二维字符串矩阵（图中主串），借助今天讲的思路，如何在其中查找另一个二维字符串矩阵呢？
    -   ![img](https://static001.geekbang.org/resource/image/00/c9/00c353326466a8ce4e790e36924704c9.jpg)