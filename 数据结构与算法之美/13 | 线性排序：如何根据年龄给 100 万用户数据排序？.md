[TOC]


## 如何根据年龄给 100 万用户数据排序？

+ 今天，我会讲三种时间复杂度是 O(n) 的排序算法：**桶排序**、**计数排序**、**基数排序**。
+ 因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作**线性排序（Linear sort）**
+ 之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素间的比较操作。
+ 这几种排序算法理解起来不难，时间、空间复杂度分析起来也很简单，但是对要排序的数据要求很苛刻，所以，我们今天学习的重点是**掌握这些排序算法的适用场景。**
+ **开篇题：**
    + **如何根据年龄给 100 万用户排序？**
    + 有没有一种较之前排序更快的方法呢？

### 桶排序（Bucket sort）

+ 桶排序，顾名思义，会用到“桶”，核心思想是**将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排序完成后，再把桶里的数据按照顺序依次取出，组成的序列就是有序的了。**
+ ![](http://ww3.sinaimg.cn/large/006tNc79ly1g52ry4emx7j30vq0jl76p.jpg)
+ 桶排序的时间复杂度为什么是 O(n) 呢？我们一块来分析一下：
    + 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶就有 `k=n/m` 个元素。
+ **桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？**
    + 答案是否定的。实际上桶排序对要排序的数据的要求非常苛刻。
        + 首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然大小顺序。这样每个桶的数据都排序之后，桶与桶之间的数据不需要再进行排序。
        + 其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。
+ **桶排序比较适合用在外部排序中**
    + 所谓外部排序就是数据存储在外部磁盘中，数据量较大，内存有限，无法将数据全部加载到内存中。
+ 比如说，我们有 10GB 的订单数据，我们希望按订单金额（金额都是正整数）进行排序，但是，我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？
+ 如何借助桶排序的处理思想来解决这个问题。
    + 我们可以先扫描一遍文件，看订单金额所处的数据范围。
    + 假设经过扫描后，我们得到，订单金额最小是 1 元，最大是 10 万元。
    + 我们将所有订单根据金额分到 100 个桶里，第一个桶存储 1～1000 元，第二个桶是 1001～2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名(00, 01, 02...99)
    + 理想情况下，如果订单金额在 1 到 10 万间均分布，那订单会被均匀分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件排好序后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。
    + 不过，也有可能 ，订单金额在 1元～10万元之间并不一定是均匀分布的，所以，10GB 数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多了，划分后对应的文件就会很大，没法一次读入内存。这又该怎么办呢？
        + 针对这些划分后还是较大的文件，我们可以继续划分，直到所有的文件都能读入内存为止。

### 计数排序（Counting sort）

+ **计数排序其实是桶排序的一种特殊情况。**

+ 当要排序 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。第个桶内的数据值都相同的，省掉了桶内的排序时间。

+ 因为桶排序只涉及扫描遍历操作，所以**时间复杂度是 O(n)**

+ **不过，为什么这个排序算法叫“计数排序”呢？“计数”的含义来自哪里呢？**

    + 想弄明白这个问题，我们就要来看计数排序的实现方法。设有 8 个考生，分数在 0～5 之间，这 8 个考生的成绩我们放在一个数组 A[8] 中。它们分别是：2，5，3，0，2，3，0，3.
    + 考生的成绩从 0～5 分，我们使用大小为 6的数组 C[6] 表示桶，其中下标对应分数。不过 C[6] 内存储的并不是考生，而是考生个数。像我们刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6] 的值。
    + 从下图中可以看得出，分数为 3 的考生只有 3 个，小于 3 分的考生有 4 个，所以成绩为 3 分的考生在排序后的有序数组 R[8] 中，会保存在下标 4，5，6 的位置。
    + ![361f4d781d2a2d144dcbbbb0b9e6db29](http://ww1.sinaimg.cn/large/006tNc79ly1g52tcyuckgj30vq0bgdgh.jpg)

+ **那我们如何计算出，每个分数的考生在有序数组中对应的存储位置呢？**这个处理方法非常巧妙。

    + 思路是这样的：我们对 C[6] 数组顺序求和，C[6] 存储的数据就变成了下面这样子。C[k] 里存储小于等于分数 k 的考生个数。

    + ![](http://ww1.sinaimg.cn/large/006tNc79ly1g52tgzs7ahj30vq06sgll.jpg)

    + **下面就要讲计数排序最复杂、最难理解的一部分了**

    + 我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3] 要减 1，变成 6。

    + 以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的元素）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列了。

    + ![](http://ww1.sinaimg.cn/large/006tNc79ly1g52tpucfxcj30u013zadl.jpg)

    + 实现代码如下

    + ```java
        // 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。
        public void countingSort(int[] a, int n) {
          if (n <= 1) return;
        
          // 查找数组中数据的范围
          int max = a[0];
          for (int i = 1; i < n; ++i) {
            if (max < a[i]) {
              max = a[i];
            }
          }
        
          int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max]
          for (int i = 0; i <= max; ++i) {
            c[i] = 0;
          }
        
          // 计算每个元素的个数，放入 c 中
          for (int i = 0; i < n; ++i) {
            c[a[i]]++;
          }
        
          // 依次累加
          for (int i = 1; i <= max; ++i) {
            c[i] = c[i-1] + c[i];
          }
        
          // 临时数组 r，存储排序之后的结果
          int[] r = new int[n];
          // 计算排序的关键步骤，有点难理解
          for (int i = n - 1; i >= 0; --i) {
            int index = c[a[i]]-1;
            r[index] = a[i];
            c[a[i]]--;
          }
        
          // 将结果拷贝给 a 数组
          for (int i = 0; i < n; ++i) {
            a[i] = r[i];
          }
        }
        
        ```

+ 总结一下：

    + **计数排序只能在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其地类型的，要将其在不改变相对大小的情况下，转化为非负整数。**
    + 比如，考生成绩精确到小数点后一位，我们就需要将所有分数都先乘 10，转化成整数，然后再放到 9010 个桶内。
    + 再比如，如果要排序的数据中有负数，数据的范围是[-1000，1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。

### 基数排序（Radix sort）

+ 我们再来看一个排序问题。假设我们有 10 万个手机号码，希望将这 10 万个手机号从小到大排序，你有什么比较快速的排序方法呢？
+ 手机号码有 11 位，范围太大，桶排序和计数排序显示不适用。
+ 这个问题有这样的规：假设比较两个手机号码 a，b 的大小，**如果在前面几位中 a 手机号码已经比 b 手机号码大了，那后面几位也就不用看了。**
+ 借助稳定排序算法，这里有一个巧妙的实现思路。
    + 先按照最后一位来排序手机号码，然后再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序后，手机号码就都有序了。
+ 下面一张基数排序的过程分解图
+ ![](http://ww2.sinaimg.cn/large/006tNc79ly1g52v7qqqgbj30vq0e774k.jpg)
+ 注意，**这里按照每位来排序算法要是稳定的**。
+ 它的时间复杂度是 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度就是 O(k*n) 。当 k 不大的时候，如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。
+ **实际上，有时候要排序的数据并不是等长的。**如要排序牛津字典中 20 万个英文单词。
    + 对于此类，**我们可以把所有的单词补齐到相同的长度，位数不够的可以在后面补 0**
+ 总结：
    + **基数排序对要排序的数据是有要求的**，
        + **需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了**。
        + **除此外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了**。

### 解答开篇

+ 如何根据年龄来给 100 万用户排序？
+ 思路：
    + 实际上，根据年龄给 100 万用户排序，就类似之前按照成绩给 50 万考生排序。
    + 假设年龄的范围是 1～120。**我们就可以遍历这100 万个用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。**
    + 这样就得到了按照年龄排序的 100 万用户数据。

### 内容小结

+ 今天，我们学习了 3 种线性时间复杂度的排序算法，**桶排序，计数排序，基数排序**
+ 它们对要排序的数据都有比较苛刻的要求，应用不是很广泛。但是，如果数据特殊比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。
+ 桶排序和计数排序的思想是非常相似的，都是针对范围不大的数据，将数据划分到不同的桶来实现排序。
+ 基数排序要求数据可以划分高低位，位间有递进关系。比较两个数，我们只需要借助桶排序或者计数排序来完成每一位的排序工作。


### 课后思考

+ 今天讲的都是针对特殊数据的排序算法。实际上，还有很多看似是排序但又不需要使用排序算法就能处理的排序问题。
+ 假设我们现在需要对 D, a, F, B, c, A, z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但，小写字母和大写字母内部不要求有序。