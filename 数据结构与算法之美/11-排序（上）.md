[toc]


## 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？

### 如何分析一个排序算法？

1.  执行效率
    -   **最好情况、最坏情况、平均情况**时间复杂度
    -   时间复杂度的**系数、常数、低阶**
    -   **比较**次数和**交换**（或移动）次数
2.  内存消耗
    -   **原地排序**
        -   指**空间复杂度是 O(1)** 的排序算法。
3.  稳定性
    -   定义：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
    -   稳定的排序算法：前后顺序**没有改变**
    -   不稳定的排序算法：前后顺序**发生变化**

### 冒泡排序（Bubble Sort）

1.  算法思想

    -   冒泡排序只会操作**相邻**的两个数据。
    -   每次冒泡操作都会对相邻两个元素进行比较，看是否满足大小关系要求。如果不满足就让它们交换。
    -   一次冒泡会让至少一个元素移动它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

2.  流程图

    -   ![img](imgs/9246f12cca22e5d872cbfce302ef4d09.jpg)

3.  实现

    -   ```java
        
        // 冒泡排序，a表示数组，n表示数组大小
        public void bubbleSort(int[] a, int n) {
          if (n <= 1) return;
         
         for (int i = 0; i < n; ++i) {
            // 提前退出冒泡循环的标志位
            boolean flag = false;
            for (int j = 0; j < n - i - 1; ++j) {
              if (a[j] > a[j+1]) { // 交换
                int tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
                flag = true;  // 表示有数据交换      
              }
            }
            if (!flag) break;  // 没有数据交换，提前退出
          }
        }
        ```

4.  分析

    -   一、冒泡排序是**原地排序**算法吗？
        -   空间复杂度为 O(1)，是一个原地排序算法。
        -   冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，不涉及额外的申请空间。
    -   二、冒泡排序是**稳定的排序**算法吗？
        -   是稳定的排序算法。
        -   为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换。

    -   三、冒泡排序的**时间复杂度**是多少？

        -   最好：O(n)

        -   最坏：O(n2)。

        -   平均

            >   有序度：是数组中具有有序关系的元素对的个数。计算公式 `n*(n-1)/2`
            >
            >   逆序度：定义正好跟有序度相反
            >
            >   满有序度：完全有序
            >
            >   计算公式：逆序度 = 满有序度 - 有序度
            >
            >   推导过程：0 ~ `n*(n-1)/2` => `n*(n-1)/4` => `O(n^2)`

### 插入排序（Insertion Sort）

1.  算法思想
    -   首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。
    -   初始已排序区间只有一个元素，就是数组的第一个元素。
    -   **核心思想**是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。
    -   重复这个过程，直到未排序区间中元素为空，算法结束。
    
2.  流程图
    
    -   ![img](https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg)
    
3.  实现

    -   ```java
        
        // 插入排序，a表示数组，n表示数组大小
        public void insertionSort(int[] a, int n) {
          if (n <= 1) return;
        
          for (int i = 1; i < n; ++i) {
            int value = a[i];
            int j = i - 1;
            // 查找插入的位置
            for (; j >= 0; --j) {
              if (a[j] > value) {
                a[j+1] = a[j];  // 数据移动
              } else {
                break;
              }
            }
            a[j+1] = value; // 插入数据
          }
        }
        ```

4.  分析

    -   一、插入排序是**原地排序**算法吗？
        -   空间复杂度是 O(1)，是原地排序算法。
    -   二、插入排序是**稳定的排序**算法吗？
        -   对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
    -   三、插入排序的**时间复杂度**是多少？
        -   最好：O(n)
        -   最坏：O(n^2)
        -   平均：O(n^2)

### 选择排序（Selection Sort）

1.  算法思想

    -   也分已排序区间和未排序区间。
    -   选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

2.  流程图

    -   ![img](imgs/32371475a0b08f0db9861d102474181d.jpg)

3.  实现

    -   ```python
        def selection_sort(collection: List[int]) -> List[int]:
            """
            选择排序
            """
            length = len(collection)
            for i in range(length - 1):
                min_index = i + 1
                for j in range(i, length):
                    if collection[j] < collection[min_index]:
                        min_index = j
                # swap
                if min_index != i:
                    collection[min_index], collection[i] = collection[i], collection[min_index]
            return collection
        ```

4.  分析

    -   一、选择排序是**原地排序**算法吗？
        -   空间复杂度是 O(1)，是一种原地排序算法。
    -   二、选择排序是**稳定的排序**算法吗？
        -   选择排序是一种不稳定的排序算法
    -   三、选择排序的**时间复杂度**是多少？
        -   最好：O(n^2)
        -   最坏：O(n^2)
        -   平均：O(n^2)

### 解答开篇

1.  问题：冒泡排序和插入排序的时间复杂度都是 O($n^2$)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

    -   从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。

    -   ```java
        冒泡排序中数据的交换操作：
        if (a[j] > a[j+1]) { // 交换
           int tmp = a[j];
           a[j] = a[j+1];
           a[j+1] = tmp;
           flag = true;
        }
        
        插入排序中数据的移动操作：
        if (a[j] > value) {
          a[j+1] = a[j];  // 数据移动
        } else {
          break;
        }
        
        
        ```

        

### 课后思考

+ 今天讲的几种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？

#### 精选留言

1.  #双木公子

    >   对于老师所提课后题，觉得应该有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。
    >
    >   一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。
    >
    >   综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。

2.  #Smallfly

    >   二刷了下排序，有了一些新的体会。
    >
    >   冒泡、插入、选择排序都有一个共同点，将待排序数列分为已排序和未排序两部分。在未排序的部分中查找一个最值，放到已排序数列的恰当位置。
    >
    >   具体到代码层面，外层循环的变量用于分割已排序和未排序数，内层循环的变量用于在未排序数中查找。从思路上看，这三种算法其实是一样的，所以时间复杂度也相同。