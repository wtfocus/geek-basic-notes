[TOC]

## 22 | 哈希算法（下）：哈希算法在分布式系统中有哪些应用？

![](http://ww4.sinaimg.cn/large/006tNc79ly1g5lbzf0irfj30vq0hs74x.jpg)

- **负载均衡**、**数据分片**、**分布式存储**
- **哈希算法是如何解决这些分布式问题的？**

### 应用五：负载均衡

- 实现一个会话粘滞（session sticky）的负载均衡算法。（同一客户端上，一次会话中的所有请求都路由到同一服务器上。）
    - **通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值 ，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。**

### 应用六：数据分片

- 哈希算法用于数据分片的如下两个例子。

#### 1. 如何统计“搜索关键词”出现次数？

- 假设，我们有 1T 的日志文件，里而记录了用户的搜索关键词。我们想要快速统计出每个关键词被搜索的次数，该怎么办？
- 这里有两个难点：
    1. 日志量很大，没办法放到一台机器的内存中。
    2. 如果用一台机器来处理这么大的数据，处理时间会很长。
- 解决方案：
    1. **先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。**
- 具体思路：
    - 用 n 台机器并行处理。
    - **从搜索日志中，依次读出每个搜索关键词，并通过哈希函数计算哈希值，然后跟 n 取模，最终得到的值，就是应该被分配到的机器的编号。**
    - 这样，哈希值相同的搜索关键词就被分配到同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。
- 这里处理过程也是 MapReduce 的基本设计思想。

#### 2. 如何快速判断图片是否在图库中？

- 假设，我们图库中有 1 亿张图片，如何判断图片是否在图库中呢？
- 在单台机器上构建散列表肯定是行不通的。（内存有限）
- 思路：
    - 采用多机处理，我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就是对应要分配机器的编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。
    - 当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算图片唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k ，那就去编号 k 的机器构建的散列表查找。
- 针对海量数据，我们都可以采用多机分布式处理。借助这种分片思路，可以突破单机内存、CPU 等资源的限制。

### 应用七：分布式存储

- 对于分布式缓存。我们有海量数据需要缓存。所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。
- **那如何决定将哪个数据放到哪个机器上呢？**
    - 我们借助数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。
- 随着数据增多，原来 10 个机器已经无法承受了。我们就需要**扩容**。那麻烦就来了，因为，这里并不是简单的加个机器就可以了。数据也需要重新分配存储的机器。如下图
- ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5o2hzcur9j30vq0iqt91.jpg)
- 因此，**所有数据都需要重新计算哈希值，然后重新搬移到正确的机器上。**这就相当于，所以缓存一下子就都失效了。所有数据请求都会穿透缓存，直接去请求数据库。这样就可能发生**雪崩效应**，压垮数据库。
- **一致性哈希算法**
    - 假设我们有 k 个机器，数据的哈希值的范围是[0，MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器上搬移到新的机器机中。这样就既不用全部重新哈希、搬移数据，也保持了各个机器上的数据量均衡。
- 一致性哈希的应用非常广泛。

### 解答开篇 & 内容小结

- 今天我讲了三种哈希算法在分布式系统中的应用，它们分别是
    - 负载均衡
        - 利用哈希算法替代映射表，实现一个会话粘滞的负载均衡策略。
    - 数据分片
        - 通过哈希算法对处理海量数据进行分片，多机分布式处理，可以突破单机资源的限制。
    - 分布式存储
        - 利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的问题。

### 课后思考 

- 除了我们这两节讲的七个哈希算法的应用，你还能想到其他用到哈希算法的地方吗？

    