[TOC]

## 如何定位 IP 对应的省份地址？ 

+ **假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？**
+ 上一节我们讲了二分查找的原理，并且介绍了简单的一种二分查找的代码实现。今天我们来讲几个二分查找的变形问题。
+ 有这样一个说法：“十个二分九个错”。二分查找虽然原理极其简单，但是想要写出没有 bug 的二分查找并不容易。
+ 二分查找的变形问题很多，我只选择几个典型的来讲解。
+ ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5b74dfx9jj30vq0lrgn8.jpg)
+ 特别说明一点，为了简化讲解，今天的内容，我们都是从小到大排列为前提，如果你要处理的数据是从大到小排列，解决思路也是一样的。

### 变体一： 查找第一个值等于给定值的元素

+ 上一节的二分查找是最简单的一种，即有序数据集合中不存在重复的数据，我们在其中查找值等于某个给定值的数据。

+ **如果有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据**，这样之前的二分查找代码还能继续工作吗?

+ 比如下面这样一个有序数组。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素。

+ ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5b790iyy1j30vq07wgln.jpg)

+ 针对这种变形问题，我们在上一节的基础上稍微改造一下代码。

+ ```java
    public int bsearch(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
      while (low <= high) {
        int mid = low + ((high - low) >> 1);
        if (a[mid] >= value) {
          high = mid - 1;
        } else {
          low = mid + 1;
        }
      }
    
      if (low < n && a[low]==value) return low;
      else return -1;
    }
    
    ```

+ 网上很多关于变形的二分查找的实现方法，有很多写得非常简洁。但，尽管简洁，理解起来却非常烧脑。如下：

+ ```java
    public int bsearch(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
      while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] > value) {
          high = mid - 1;
        } else if (a[mid] < value) {
          low = mid + 1;
        } else {
          if ((mid == 0) || (a[mid - 1] != value)) return mid;
          else high = mid - 1;
        }
      }
      return -1;
    }
    
    ```

+ 我来稍微解释下这段代码，`a[mid]` 跟查找的 value 的大小关系有三种情况：大于、小于、等于。

    + 对于`a[mid]>value` 的情况，我们需要更新 `high=mid-1`;
    + 对于`a[mid]<value` 的情况，我们需要更新`low=mid+1`;
    + 那对于`a[mid]=value` 的情况，应该如何处理呢？
        + 如果我们查找的任意一个值等于给定值的元素，当 `a[mid]` 等于要查找的值时，`a[mid]` 就是我们要找的元素。但，如果我们求解的是第一个值等于给定值的元素，当`a[mid]` 等于要查找的值时，我们就需要确认一下这个 `a[mid]` 是不是第一个值等于给定值的元素。
        + 我们重点看第 11 行代码。
            + 如果 **mid 等于 0**，那这个元素已经是数组的第一个元素，那它肯定就是我们要找的。
            + 如果 mid 不等于 0，**但 `a[mid]` 的前一个元素`a[mid-1]` 不等于 value** ，那也说明`a[mid]` 就是我们要找的第一个等于给定值的元素。
            + 如果经过检查的，**发现 `a[mid]` 前面的一个元素 `a[mid-1]`也等于 value**。那说明此时的 `a[mid]` 一定不是我们要查找的第一个值等于给定值的元素。那我们就更新 `high=mid-1`，因为要找的值肯定出现在 `[low, mid-1]` 之间。 
    + 对比上面两段代码，我们发现。实际上，很多人觉得变形的二分查找算法很难写，主要原因是太追求第一种那样完美、简洁的写法。

### 变体二：查找最后一个值等于给定值的元素

+ 我们现在把问题稍微改一下，查找最后一个值等于给定值的元素，又该如何做呢？

+ ```java
    public int bsearch(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
      while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] > value) {
          high = mid - 1;
        } else if (a[mid] < value) {
          low = mid + 1;
        } else {
          if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
          else low = mid + 1;
        }
      }
      return -1;
    }
    
    ```

+ 我们还是重点看第 11 行代码。

    + 如果 **`a[mid]` 这个元素已经是数组中最后一个元素了**，那它肯定是我们要找的。
    + 如果**`a[mid]`的后一个元素`a[mid+1]`不等于 value **，那也说明 `a[mid]`就是我们要找的最后一个值等于给定值的元素。
    + 如果**`a[mid]`的后面的一个元素`a[mid+1]`也等于 value**，那说明当前这个 `a[mid]` 并不是最后一个值等于给定值的元素。我们就更新`low=mid+1`，因为要找的元素肯定出现在`[mid+1, high]` 之间。

### 变体三： 查找第一个大于等于给定值的元素

+ 我们再来看另一类变形的问题。在一个有序数组中，查找第一个大于等于给定值的元素。

+ 代码实现思路跟前面两个思路类似，如下：

+ ```java
    public int bsearch(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
      while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] >= value) {
          if ((mid == 0) || (a[mid - 1] < value)) return mid;
          else high = mid - 1;
        } else {
          low = mid + 1;
        }
      }
      return -1;
    }
    ```

+ 如果`a[mid]`小于要查找的值 value，那要查找的值肯定在 `[mid+1, high]`之间。所以，我们更新 `low=mid+1`。

+ 如果`a[mid]`大于等于给定值的 value 的情况，我们要先看下这个 `a[mid]` 是不是我们要找的第一个值大于等于给定值的元素。

    + 如果`a[mid]`前面已经没有元素，或者前面一个元素小于要查找的值value，那`a[mid]` 就是我们要找的元素。
    + 这段逻辑对应代码第 7 行。

+ 如果 `a[mid-1]`也大于等于要查找的值 value，那说明要查找的元素在 `[low, mid-1]`之间，所以，我们将 high 更新为 `mid-1`。

### 变体四： 查找最后一个小于等于给定值的元素

+ 我们来看看最后一种二分查找的变形问题，查找最后一个小于等于给定值的元素。跟上面的实现思路也是一样的。

+ ```java
    public int bsearch7(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
      while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] > value) {
          high = mid - 1;
        } else {
          if ((mid == n - 1) || (a[mid + 1] > value)) return mid;
          else low = mid + 1;
        }
      }
      return -1;
    }
    
    ```

+ 

### 解答开篇

+ 现在我们回头来看开篇的问题： **如何快速定位出一个 IP 地址的归属地？**
+ 如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。
    + 如果排序呢？我们知道，IP 地址可以转化为 32 位整型数。所以，我们可以将起始的地址，按照对应的整型值的大小关系，从小到大进行排序。
+ 然后，这个问题就可以转化为我们刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素了。”
+ 当我们要查询某个 IP 归属地时，我们可以先通过二分查找 ，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间。
    + 然后，检查这个 IP 是否在这个IP 区间内，如果在，我们就取出对应的归属地显示。
    + 如果不在，就返回未查到。

### 内容小结

+ 上节，我说过，凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或二叉查找树。
    + 即使是二分查找在内在使用上更节省，但，毕竟内在如此紧缺的情况并不多。那二分查找真的没什么用处了吗？
+ 实际上，上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如今天讲的这种变体的问题，用其他数据结构，如散列表、二叉树，就比较难实现了。
+ 变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生 BUG，这些容易出错的细节有：
    + 终止条件
    + 区间上下界更新方法
    + 返回值选择

### 课后思考

+ 今天的思考题也是一个非常规的二分查找的问题。如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？

#### 精选一

+ 有三种方法查找循环有序数组

##### 第一

1. 找到分界下标，分成两个有序数组。
2. 判断目标值在哪个有序数据范围内，做二分查找 。

##### 第二

1. 找到最大值的下标 x。
2. 所有元素下标 `+x` 偏移，超过数组范围值的取模。
3. 利用偏移后的下标做二分查找 。
4. 如果找到目标下标，再作 `-x` 偏移，就是目标值实际下标。
5. 时间复杂度是`O(n)`

##### 第三

+ 我们发现循环数组存在一个性质：**以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。**
    + 如果首元素小于 mid，说明前半部分有序，后半部分是循环有序数组。
    + 如果首元素大于 mid，说明后半部分有序，前半部分是循环有序数组。
    + 如果目标元素在有序数组范围中，使用二分查找。
    + 如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找 。
+ 时间复杂度是 `O(logn)`

