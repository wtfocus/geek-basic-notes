[TOC]

## 16 | 二分查找（下）：如何定位 IP 对应的省份地址？ 

1.  开篇题

    -   假设我们有 12 万条这样的 IP 区间与归属地的对应关系。**如何快速定位出一个 IP 地址的归属地呢？**

        -   ```
            [202.102.133.0, 202.102.133.255]  山东东营市 
            [202.102.135.0, 202.102.136.255]  山东烟台 
            [202.102.156.34, 202.102.157.255] 山东青岛 
            [202.102.48.0, 202.102.48.255] 江苏宿迁 
            [202.102.49.15, 202.102.51.251] 江苏泰州 
            [202.102.56.0, 202.102.56.255] 江苏连云港
            ```

2.  二分查找的**变形问题**很多，我只选择几个典型的来讲解。
    
    -   ![img](imgs/4221d02a2e88e9053085920f13f9ce36-1206626.jpg)

### 变体一： 查找第一个值**等于**给定值的元素

1.  **如果有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据**
    -   有序数据集合如下：
    -   ![](imgs/006tNc79ly1g5b790iyy1j30vq07wgln.jpg)

2.  代码

    -   ```java
        public int bsearch(int[] a, int n, int value) {
          int low = 0;
          int high = n - 1;
          while (low <= high) {
            int mid =  low + ((high - low) >> 1);
            if (a[mid] > value) {
              high = mid - 1;
            } else if (a[mid] < value) {
              low = mid + 1;
            } else {
              if ((mid == 0) || (a[mid - 1] != value)) return mid;
              else high = mid - 1;
            }
          }
          return -1;
        }
        ```

    -    我们**重点**看第 11 行代码。

         1.  如果 **mid 等于 0**，那这个元素已经是数组的第一个元素，那它肯定就是我们要找的。

         2.  如果 mid 不等于 0
             -   **但 `a[mid]` 的前一个元素`a[mid-1]` 不等于 value** ，那也说明`a[mid]` 就是我们要找的第一个等于给定值的元素。
             -   如果经过检查的，**发现 `a[mid]` 前面的一个元素 `a[mid-1]`也等于 value**。那说明此时的 `a[mid]` 一定不是我们要查找的第一个值等于给定值的元素。那我们就更新 `high = mid - 1`，因为要找的值肯定出现在 `[low, mid-1]` 之间。 

### 变体二：查找最后一个值**等于**给定值的元素

1.  代码

    -	 ```java
        public int bsearch(int[] a, int n, int value) {
          int low = 0;
          int high = n - 1;
          while (low <= high) {
            int mid =  low + ((high - low) >> 1);
            if (a[mid] > value) {
              high = mid - 1;
            } else if (a[mid] < value) {
              low = mid + 1;
            } else {	// 重点逻辑
              if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
              else low = mid + 1;
            }
          }
          return -1;
        }

        ```

### 变体三： 查找第一个**大于等于**给定值的元素

1.  代码

    -	```java
        public int bsearch(int[] a, int n, int value) {
          int low = 0;
          int high = n - 1;
          while (low <= high) {
            int mid =  low + ((high - low) >> 1);
            if (a[mid] >= value) {	// 重点逻辑
              if ((mid == 0) || (a[mid - 1] < value)) return mid;
              else high = mid - 1;
            } else {
              low = mid + 1;
            }
          }
          return -1;
        }
        ```

### 变体四： 查找最后一个小于等于给定值的元素

1.  代码

    - 	```java
        public int bsearch7(int[] a, int n, int value) {
          int low = 0;
          int high = n - 1;
          while (low <= high) {
            int mid =  low + ((high - low) >> 1);
            if (a[mid] > value) {
              high = mid - 1;
            } else {	// 重点逻辑
              if ((mid == n - 1) || (a[mid + 1] > value)) return mid;
              else low = mid + 1;
            }
          }
          return -1;
        }

        ```

### 解答开篇

1.  问题： **如何快速定位出一个 IP 地址的归属地？**
2.  解题方案
    -   如果 IP 区间与归属地的对应关系**不经常更新**
    -   我们可以先**预处理**这 12 万条数据，让其按照起始 IP 从小到大**排序**。
    -   然后，这个问题就可以转化为我们刚讲的第四种变形问题“**在有序数组中，查找最后一个小于等于某个给定值的元素**”了。
    -   我们先通过二分查找 ，找到**最后一个起始 IP 小于等于这个 IP 的 IP 区间**。
    -   然后，检查这个 IP 是否在这个IP 区间内
        -   如果在，我们就取出对应的归属地显示。
        -   如果不在，就返回未查到。

### 小结

1.  二分查找更适合用在“**近似**”查找问题。在这类问题上，二分查找的优势更加明显。

2.  变体的二分查找算法需要注意的细节

    -   **终止条件**

    -   **区间上下界更新方法**

    -   **返回值选择**

### 课后思考

1.  如果有序数组是一个**循环有序数组**，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？

#### 精选留言

1.  #Smallfly

    >   有三种方法查找循环有序数组
    >
    >    一、
    >    \1. 找到分界下标，分成两个有序数组
    >
    >    \2. 判断目标值在哪个有序数据范围内，做二分查找
    >
    >   
    >
    >    二、
    >    \1. 找到最大值的下标 x;
    >
    >    \2. 所有元素下标 +x 偏移，超过数组范围值的取模;
    >
    >    \3. 利用偏移后的下标做二分查找；
    >
    >    \4. 如果找到目标下标，再作 -x 偏移，就是目标值实际下标。
    >
    >    两种情况最高时耗都在查找分界点上，所以时间复杂度是 O(N）。
    >
    >    复杂度有点高，能否优化呢？
    >
    >   
    >
    >    三、（重点）
    >   我们发现循环数组存在一个性质：**以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。**
    >
    >    如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组；
    >
    >    如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；
    >
    >    如果目标元素在有序数组范围中，使用二分查找；
    >
    >    如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。
    >
    >    时间复杂度为 O(logN)。