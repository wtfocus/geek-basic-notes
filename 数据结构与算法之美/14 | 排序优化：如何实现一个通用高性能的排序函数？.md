[TOC]

## 如何实现一个通用的、高性能的排序函数？ 

+ **如何实现一个通用的、高性能的排序函数？**

###如何选择合适的排序算法？

+ 前面讲过的几种排序算法
+ ![](http://ww2.sinaimg.cn/large/006tNc79ly1g53wwrim8fj30vq0jejsk.jpg)
+ 线性排序算法的时间复杂度比较低，适用场景比较特殊。所以，如果要写一个通用的排序函数，不能选择线性排序算法。
+ 小规模数据进行排序，可以选择时间复杂度是 O($n^2$) 的算法。如果对于大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模的数据排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。
+ 时间复杂度是 O(nlogn) 的排序算法不止一个。
    + 其实发现，归并排序的情况其实并不多。归并排序的时间复杂度可以做到 O(nlogn)。但，归并排序并不是原地排序算法，空间复杂度是 O(n)。
    + 前面讲到，快速排序比较适合来实现排序函数，但，快速排序在最坏情况下时间复杂度是 O($n^2$)，如何来解决这个“复杂度恶化”的问题呢？

###如何优化快速排序

+ 这种 O($n^2$)时间复杂度出现的主要原因还是因为我们**分区点选的不够合理**。
+ 最理想的分区点是：**被分点分开的两个分区中，数据的数量差不多。** 
+ 这里，我们介绍两个比较常用的、比较简单的分区算法，你可以直观地感受一下。

####1. 三数取中法

+ 从区间首、中、尾分别取出一个数，然后对比大小，取 3 个数的中间值作为分区点。
+ 如果，要排序的数组比较大，那“三数取中法”可以变成“五数取中”、“十数取中”。

####2. 随机法

+ 随机法，就是每次从要排序的区间中，随机选择一个元素作为分区点。
+ 这种方法并不能保证每次分区点选的比较好，但是，从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况。

###举例分析排序函数

+ Glibc 中的 qsort() 函数来举例说明。
    + `qsort()` 会**优先使用归并排序**来排序输入数据，
        + 对小规模数据很有效率。
    + 在数据量较大的时候，`qsort()` 会改为用快速排序算法来排序。
        + 选择分区点时，`qsort()` 使用了“三数取中法”。
    + 当排序数量小于等于 4 时，`qsort()` 使用插入排序。
        + 在小规模数据面前，**O($n^2$)  时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。**现在我们就来分析下这个说法。
            + 我们前面分析时候讲过，算法性能可以用时间复杂度来分析，但是，这种复杂度分析偏理论，如果我们深究的话，**实际上时间复杂度并不等于代码实际运行时间。**
            + 时间复杂度代表的是一个增长趋势。我们前面讲过，在大 O 时间表示法中，我们会省略低阶、系数、常数，也就是说 O(nlogn) 在没有省略低阶、系数、常数前可能是`O(knlogn + c)`，而且，k 和 c 可能是一个比较大的数。
            + 所以，对于小规模数据的排序， O($n^2$) 排序算法并不一定比 O(nlogn) 排序算法执行时间长。**对于小规模数量的排序，我们选用比较简单、不需要递归的插入排序算法。**
        + `qsort()` 也利用哨兵这咱编程技巧。虽然哨兵可能只是减少一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能优化需要做到极致。

###内容小结

+ 今天我们分析了一下如何实现一个工业级的通用的、高效的排序函数，内容较偏实战，而且贯穿了一些前几节的内容，需要多看几遍。我们大部分排序函数都采用 `O(nlogn)` 排序算法来实现，但是为了尽可能地提高性能，会做很多优化。
+ 我们还讲了快速排序的优化策略，比如合理选择分区点，避免递归太深等。
+ 最后，我们还分析了一个 C 语言中的 `qsort()` 底层原理，希望能对你有一个直观的感受。 

###课后思考

+ 今天，我们一起分析了 `qsort()` 的实现，你能否分析下你所熟悉的语言中的排序函数都是用什么排序算法来实现的呢？都有哪些优化技巧？