[TOC]

## 如何用最省内存的方式实现快速查找功能？

+ 我们来看一道思考题：
    + 假设我们有 1000 万整数数据，每个数据占用 8 个字节，**如何设计数据结构算法，快速判断某个整数是否出现在这 1000 万数据中？**我们希望这个功能不要占用太多的内存空间，最多不超过 100MB，你会怎么做呢？

### 无处不在的二分思想

+ 我们来做一个猜字游戏。我随机写一个 0～99 间的数字，然后你来猜我写的是什么。猜的过程，你每猜一次，我就会告诉你大了还是小了，直到猜中为止。
    + 假设我写的数字 23，你可以按照如下步骤来试一试
    + ![](http://ww4.sinaimg.cn/large/006tNc79ly1g59oue4yl6j30vq0ni3zi.jpg)
    + 7 次就猜出来了，是不是很快？这个例子就是用的二分思想。
+ 再如，我们要在一系列订单中找到 19 元的订单。
    + 还是用二分思想，每次都与区间的中间数据比较大小，缩小查找范围。如下图，其中，low 和 high 表示待查找的区间的下标，mid 是待查找区间的中间元素的下标。
    + ![](http://ww2.sinaimg.cn/large/006tNc79ly1g59oyvjbicj30vq0mr0tj.jpg)
+ 看懂这两个例子，你现在对二分的思想应该掌握了吧。我们稍微总结升华一下：
    + **二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次通过跟区间对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。**

### O(logn) 惊人的查找速度

+ 二分查找是一种非常高效的查找算法，高效到什么程度呢？我们来分析一下它的时间复杂度。
+ 假设数据大小是 n ，每次查找后数据都会缩小为原来的一半，也就是会除以 2 。最坏情况下，直到查找区间被缩小为空，才停止。
+ ![](http://ww3.sinaimg.cn/large/006tNc79ly1g59p4geyqej30vq09d3yi.jpg)
+ 可以看出来，这是一个等比数列。其中 $n/2^k=1$ 时，k 的值就是总共缩小的次数。而每一次操作只涉两个数据的大小比较，所以，经过 k 次区缩小操作，时间复杂度就是 `O(k)`。通过 $n/2^k=1$，我们可以求得 $k=log_2n$，所以，**时间复杂度就是 O(logn)**。
+ 二分查找是我们目前为止遇到的第一个时间复杂度为 O(logn) 的算法。我这里就深入地讲讲 `O(logn)` 这种**对数时间复杂度**。这是一种极其高效的时间复杂度，有时候甚至比常量级的 `O(1)` 还要高效。为什么这么说呢？
    + 因为 logn 是一个非常“恐怖”的数量级，**即便  n 非常非常大，logn 也很小**。比如 n 等于 2 的 32 次方，这个数很大了吧，大约是 42 亿。也就是说，我们在 42 亿中查找一个数据，最多需要比较 32 次。
    + 我们前面说过，用大 O 标记法表示时间复杂度的时候，会省略常数、系数和低阶。对于常量的时间复杂度的算法来说，`O(1)` 有可能表示的是一个非常大的常量值，如 O(1000)或 O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高。
    + 反过来，对数对应的就是指数。有一个非常著名的“阿基米德与国王下棋的故事”，来感受一下指数的恐怖。

### 二分查找的递归与非递归实现

#### 非递归实现

+ 我们来看看如何实现最简单的二分查找。

+ **最简单的情况就是有序数组中不存在重复元素**，我们利用二分查找找到给定的数值。代码如下：

+ ```java
    public int bsearch(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
    
      while (low <= high) {
        int mid = (low + high) / 2;
        if (a[mid] == value) {
          return mid;
        } else if (a[mid] < value) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
    
      return -1;
    }
    
    ```

+ 现在，我们着重强调一下 **3 个容易出错的地方**。

##### 1. 循环退出条件

+ 是`low <= high` 而不是`low < high`

##### 2. mid 取值

+ 实际上，`mid = (low + high) / 2`这种写法是有问题的。
+ 如果 low 比 high 大的时候，就有可能会溢出。改进的方法是将 mid 的计算方式写成 `low + (high - low)/2`。
+ 更进一步，如果要将性能优化到极致的放，我们可以将这里的除以 2 操作转化为位运算 `low + ((high - low)>>1)`。因为相比除法运算来说，计算机处理位运算要快得多。

##### 3. Low 和 high 更新

+ `low = mid + 1`, `high = mid - 1`。注意这里的 +1 和 -1，如果写成 `low = mid`, `high = mid`，就可能会发生死循环。比如，当`high = 3, low = 3`时，如果 `a[3]`不等于 value ，就会导致循环一直不退出。

#### 递归实现

+ 实际上，**二分查找除了用循环来实现，还可以用递归来实现。**

+ 实现代码如下：

+ ```java
    // 二分查找的递归实现
    public int bsearch(int[] a, int n, int val) {
      return bsearchInternally(a, 0, n - 1, val);
    }
    
    private int bsearchInternally(int[] a, int low, int high, int value) {
      if (low > high) return -1;
    
      int mid =  low + ((high - low) >> 1);
      if (a[mid] == value) {
        return mid;
      } else if (a[mid] < value) {
        return bsearchInternally(a, mid+1, high, value);
      } else {
        return bsearchInternally(a, low, mid-1, value);
      }
    }
    
    ```

+ 



### 二分查找应用场景的局限性

+ 二分查找的时间复杂度是 `O(logn)`，查找效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很多局限性的。

#### 首先，二分查找依赖的是顺序表结构，简单点就是数组

+ 二分查找是否依赖其他数据结构？**答案是否定的**。
+ 主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问的时间复杂度是 `O(1)`。
+ **二分查找只能用在数据是通过顺序来存储的数据结构上。如果是其他的数据结构，则无法应用二分查找 。**

#### 其次，二分查找针对的是有序数据

+ **数据必须是有序的，**
+ 如果数据没有顺序，我们需要先排序。排序的时间复杂度最低的是 `O(nlogn)`。所以，**如果我们针对的是一组静态的数据结构，我们可以进行一次排序，多次二分查找 。这样的排序成本可以被均摊，二分查找的边际成本就会比较低。**
+ 如果，我们的数据集合有频繁的插入和删除操作，要想用二分查找，那么每次插入、删除操作后保证数据仍然有序，要么在每次二分查找之前都先进行排序。**针对这种动态数据集合，无论哪种方法，维护有序的成本都很高。**
+ 那针对动态数据集合，如何在其中快速查找到某个数据呢？后面**二叉树**那节我们会讲。

#### 再次，数据量太小不适合二分查找

+ **如果处理的数据量很小，完全没有必要用二分查找，顺序查找就足够了。**
    + 如果大小为 10 的数组，二分和顺序查找的速度其实差不多。
    + **只有数据量比较大的时候，二分查找的优势才会比较明显。**
+ 这里有一个例外，**如果数据间比较非常耗时，不管数据量大小，我都推荐二分查找。**我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势了。

#### 最后，数据量太大也不适合二分查找

+ **二分查找地底层是依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。**
+ 如果，我们在 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续的内存空间。注意**连续**二字，即使有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。

### 解答开篇

+ 开篇题：如何在 1000 万个整数中快速查找到某个整数？
+ 我们的内存限制是 100MB，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 80MB，符合内存的限制。先将这1000 万数据排序，希望利用二分查找，就可以快速地查找到想到的数据了。
+ 实际上，这里它暗藏了“玄机”。如果你对数据结构和算法有了解，知道散列表、二叉树这些快速查找的数据结构。你会觉得，用散列表和二叉树也可以解决这些问题。实际上是不行的。
+ 虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树也可以解决。但是，**不管是散列表还是二叉树，都会需要比较多的额外的内存空间**。如果用散列表或二叉树来存储这 1000 万数据，用 100 MB 的内在肯定是下不来的。二分查找底层依赖的是数组，这种数据结构，除本身数据外，不需要额外存储其他信息，是最省内存的存储方式。

### 内容小结

+ 今天我们学习了一种针对有序数据的高效查找算法，二分查找，它的时间复杂度是 `O(logn)`。
+ 二分查找的核心思想很简单，有点类似分治思想。即每次都通过区间中的中间元素对比，将待查找的区间缩小为一半，直到想找到要查找的元素，或者区间缩小为 0。但，二分查找的代码容易写错。你需要掌握它三个最容易出错的地方：**循环退出条件、mid 的取值、low 和 high 的更新。**
+ 二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还需要数据是有序的。
+ 对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。
+ 二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。

### 课后思考

1. 如果编程实现一个“求一个数的平方根”？要求精确到小数后 6 位。
2. 如果数据使用链表来存储，二分查找的时间复杂度就会变得很高，那查找的时间复杂度究竟是多少呢？自己来推导一下。

#### 精选一

2. 假设链表长度为 n，二分查找每次都要找到中间点（计算中忽略奇偶数差异）：
    1. 第一次查找到中间点，需要移动 n/2 次
    2. 第二次查找到中间点，需要移动 n/4 次
    3. 第二次查找到中间点，需要移动 n/8 次
    4. 以此类推，一直到 1 次
    5. 总共移动次数（查找次数）`= n/2 + n/4 + n/8 ... + 1`，这显然是一个等比数列，根据等比数列求和公式： `sum = n-1`
    6. 最后算法的时间复杂度是： `O(n-1)`，忽略常数，记为 `O(n)`时间复杂度和顺序查找时间复杂度相同。
    7. 但是，再稍微思考一下，在二分查找的时候，由于要进行多余的去处，严格来说，会比顺序查找的时间慢。