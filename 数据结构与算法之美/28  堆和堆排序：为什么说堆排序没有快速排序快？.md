[TOC]

## 28 | 堆和堆排序：为什么说堆排序没有快速排序快？

- 今天我们讲另一种特殊的树： **堆（Heap）**。
- 堆这种数据结构的应用场景非常多，最经典的莫过于堆排序了。
    - 堆排序是一种原地的、时间复杂度为 `O(nlogn)` 的排序算法。
- **在实际开发中，快速排序的性能要比堆排序好，这是为什么呢？**

### 如何理解“堆”？

- **堆是一种特殊的树**。满足如下两点，它就是一个堆：
    - **堆是一个完全二叉树**。
    - **堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值**。
- **堆必须是一个完全二叉树**
    - 完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。
- **堆中每个节点的值必须大于等于（或小于等于）其子树中每个节点的值。**
    - 堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。
- 分类：
    - **大顶堆**
        - 对于每个节点的值都大于等于子树中每个节点的值的堆。
    - **小顶堆**
        - 对于每个节点的值都小于等于子树中每个节点的值的堆。
- 看图识堆：
    - ![img](https://static001.geekbang.org/resource/image/4c/99/4c452a1ad3b2d152daa2727d06097099.jpg)
    - 其中 1， 2 是大顶堆，3 是小顶堆。4 不是堆

### 如何实现一个堆？

- 我们先要知道，**堆都支持哪些操作以及如何存储一个堆。**
- 用**数组来存储堆**的例子，如下图：
    - ![img](https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg)
    - 从图中我们可以看到，
        - 数组中下标为 i 的节，
            - **左子节点，就是下标为`i*2` 的节点。**
            - **左子节点就是下标为 `i*2+1`的节点，**
            - **父节点就是下标为 `i/2` 的节点**

#### 1. 往堆中插入一个元素

- 往堆中插入一个元素后，我们需要继续满足堆的两个特性。
- **堆化**
    - 如果我们把新插入的元素放到堆的最后，如下图，是不是不符合堆的特性。于是我们就需要进行调整，让其重新满足堆的特性。这个过程，就叫**堆化（heapify）**。
    - ![img](https://static001.geekbang.org/resource/image/e5/22/e578654f930002a140ebcf72b11eb722.jpg)
- 堆化方法：
    - **从下往上**
    - **从上往下**
- **从下往上**
    
    - 我们可以让新插入的节点和父节点对比大小。**如果不满足子节点等于父节点的大小关系，我们就互换两个节点**。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。
    
    - 图解
        
        - ![img](https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg)
        
    - 代码实现：
    
        - ```java
            public class Heap {
              private int[] a; // 数组，从下标 1 开始存储数据
              private int n;  // 堆可以存储的最大数据个数
              private int count; // 堆中已经存储的数据个数
            
              public Heap(int capacity) {
                a = new int[capacity + 1];
                n = capacity;
                count = 0;
              }
            
              public void insert(int data) {
                if (count >= n) return; // 堆满了
                ++count;
                a[count] = data;
                int i = count;
                while (i/2 > 0 && a[i] > a[i/2]) { // 自下往上堆化
                  swap(a, i, i/2); // swap() 函数作用：交换下标为 i 和 i/2 的两个元素
                  i = i/2;
                }
              }
             }
            
            ```
    
        - 

#### 2. 删除堆顶元素

- 堆中任何节点的值都大于等于（或小于等于）子树节点的值，我们可以发现，**堆顶元素存储的就是堆中数据的最大值或最小值。**

- 如果构造的是大顶堆，堆顶元素就是最大的元素，当我们删除堆顶元素后，就需要把第二大的元素放在堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。

- 分解图

    - ![img](https://static001.geekbang.org/resource/image/59/81/5916121b08da6fc0636edf1fc24b5a81.jpg)
    - 

- 不过这种方法有点问题，就是**最后堆化出来的堆并不满足完全二叉树的特性。**

    - 这种情况，我们稍微改变一下思路，就可以解决这个问题。
    - 我们把**最后节点放到堆顶**，然后利用同样的父子节点对比方法。对于不满足父子节点关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。
    - 这就是**从上往下的堆化**方法。

- 如下图。

    - 因为，我们移除的是数组中最后一个元素，而堆化的过程中，都是交换操作，不会出现数组中的“空洞”。所以，这种方法堆化出的结果，肯定满足完全二叉树的特性。
    - ![img](https://static001.geekbang.org/resource/image/11/60/110d6f442e718f86d2a1d16095513260.jpg)

- 删除过程的代码实现：

    - ```java
        public void removeMax() {
          if (count == 0) return -1; // 堆中没有数据
          a[1] = a[count];
          --count;
          heapify(a, count, 1);
        }
        
        private void heapify(int[] a, int n, int i) { // 自上往下堆化
          while (true) {
            int maxPos = i;
            if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
            if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
            if (maxPos == i) break;
            swap(a, i, maxPos);
            i = maxPos;
          }
        }
        
        ```

- 小结

    - 我们知道，一个包含 n 个节点的完全二叉树，树的高度不会超过 log<sub>2</sub>n。
    - 堆化的过程是顺着节点所在路径比较交换的，所以，堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。
    - 插入数据和删除堆项元素的主要逻辑就是堆化，所以，**往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。**

### 如何基于堆实现排序？

-   这里我们借助于堆这种数据结构实现的排序算法，就叫作**推排序**。
-   **这种排序方法的时间复杂度非常稳定，是 O(nlogn)，**
-   并且，**它还是原地排序算法**。如此优秀，它是怎么做到的呢？
-   我们可以把堆排序的过程大致分成两个大的步骤，**建堆**和**排序**

#### 1. 建堆

-   **所谓“原地”，就是不借助另一个数组，就在原数组上操作。**建堆的过程，有两种思路。

    -   第一种，**在堆中插入一个元素的思路。**
        -   尽管数组中包含 n 个数据，但，我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。
        -   然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样，我们就将包含 n 个数据的数组，组织成了堆。
    -   第二种，跟第一种截然相反。**是从后往前处理数组，并且每个数据都是从上往下堆化。**

-   如下图，我画了一个第二种实现思路的建堆分解步骤图。

    -   因为叶子节点往下堆化只能自己跟自己比较，所以，我们直接从第一个非叶子节点开始，依次堆化就行了。
    -   ![img](https://static001.geekbang.org/resource/image/50/1e/50c1e6bc6fe68378d0a66bdccfff441e.jpg)

-   代码实现

    -   ```java
        private static void buildHeap(int[] a, int n) {
          for (int i = n/2; i >= 1; --i) {
            heapify(a, n, i);
          }
        }
        
        private static void heapify(int[] a, int n, int i) {
          while (true) {
            int maxPos = i;
            if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
            if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
            if (maxPos == i) break;
            swap(a, i, maxPos);
            i = maxPos;
          }
        }
        
        ```

    -   这段代码中，我们对**下标从 n/2 开始到 1 的数据进行堆化。**

    -   下标是 n/2 + 1 到 n 的节点是叶子节点，我们不需要堆化。

    -   实际上，**对于完全二叉树来说，下标从 n/2 + 1 到 n 的节点都是叶子节点。**

-   现在，我们来看下，建堆操作的时间复杂度是多少呢？

    -   **堆排序的建堆过程的时间复杂度是 O(n)**。我们一起来推导一下。
    -   因为叶子节点不需要堆化，所以，需要堆化的节点从倒数第二层开始。**每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度k 成正比。**
    -   我把每一层节点个数和对应的高度画了出来，你可以看看。我们只需要将**每个节点的高度求和，得出的就是建堆的时间复杂度。**
        -   ![img](https://static001.geekbang.org/resource/image/89/d5/899b9f1b40302c9bd5a7f77f042542d5.jpg)
    -   将每个非叶子节点的高度求和，就是下面这个公式
        -   ![img](https://static001.geekbang.org/resource/image/f7/09/f712f8a7baade44c39edde839cefcc09.jpg)
    -   如上公式求解
        -   ![img](https://static001.geekbang.org/resource/image/62/df/629328315decd96e349d8cb3940636df.jpg)
    -   通过“等比数列”的求和公式来计算，最终结果就是下面这样：
        -   ![img](https://static001.geekbang.org/resource/image/46/36/46ca25edc69b556b967d2c62388b7436.jpg)
    -   因，h = log<sub>2</sub>n，代入公式 S，就能得到 S = O(n)。所以，建堆的时间复杂度就是 O(n)。

#### 2. 排序

-   思路：

    -   建堆结束后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把**它跟最后一个元素交换**，那最大元素就放到了下标为 n 的位置。

-   实现过程

    -   这个过程有点类似上面的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶。
    -   然后再通过堆化，将 n - 1 个元素重新构建成堆。
    -   堆化完成后，我们再取堆顶的元素，放到下标是 n-1 的位置。
    -   一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。
    -   ![img](https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg)

-   代码实现

    -   ```java
        // n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。
        public static void sort(int[] a, int n) {
          buildHeap(a, n);
          int k = n;
          while (k > 1) {
            swap(a, 1, k);
            --k;
            heapify(a, k, 1);
          }
        }
        ```

-   我们分析一下堆排序的时间复杂度、空间复杂度及稳定性。
    -   整个堆排序的过程，都只需要极个别的临时存储空间，所以，**堆排序是原地排序算法。**
    -   堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，**堆排序整体的时间复杂度是 O(nlogn)。**
    -   **堆排序不是稳定的排序算法**，因为，在排序过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以，就有可能改变值相同数据的原始相对顺序。

### 解答开篇

-   实际开发中，为什么快速排序要比堆排序性能好？
    -   第一点，**堆排序数据访问的方式没有快速排序友好。**
        -   对于快速排序来说，数据是顺序访问的。
        -   而对于堆排序来说，数据是跳着访问的。
            -   如下图中，堆化的过程中，会依次访问数组下标是 1，2， 4，8的元素。而不像快速排序那样，局部顺序访问。
            -   所以，这样对 CPU 缓存是不友好的。
            -   ![img](https://static001.geekbang.org/resource/image/83/ce/838a38286dcace89ca63895b77ae8ece.jpg)
    -   第二点，**对于同样的数据，在排序过程中，堆排序算法的数据交换要多于快速排序。**
        -   排序的两个概念
            -   有序度
            -   逆序度
        -   **快速排序的数据交换次数不会比逆序度多。**
        -   而，堆排序的第一步是建堆，建堆的过程是打乱数据原有的相对先后顺序。导致原数据的有序度降低。比如，对于一组已经有序的数据来说，**经过建堆，数据反而变得更无序了。**
        -   ![img](https://static001.geekbang.org/resource/image/6e/bd/6e81fdde42ec3fd288d32eb866867fbd.jpg)

### 内容小结

-   今天，我们讲了堆这种数据结构。
-   **堆是一种完全二叉树。**
-   它最大的特性是：**每个节点的值都大于等于（或小于等于）其子树节点的值。**
    -   因此，堆被分成了两类，
        -   **大顶堆**
        -   **小顶堆**
-   堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都需要堆化。
    -   插入一个数据时候，
        -   我们把新插入的数据放到数组的最后，然后，**从下往上**堆化。
    -   删除堆顶数据的时候
        -   我们把数组中最后一个元素放到堆顶，然后，**从上往下**堆化。
    -   时间复杂度
        -   **O(logn)**
-   堆排序
    -   堆排序包含两个过程
        -   建堆
        -   排序
    -   实现过程
        -   我们将下标从 n/2 到 1 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。
        -   接下来，我**们迭代地将堆顶的元素放到堆末尾，并将堆的大小减一，然后再堆化。**
        -   重复这个过程，直到堆中只剩下一个元素，整个数组中就都有序排列了。

### 课后思考

1.  在讲堆排序建堆的时候，我说到，对于完全二叉树来说，下标从 n/2 + 1 到 n 的都是叶子节点，这个结论是怎么推导出来的呢？
2.  关于堆，你还能想到它的其他应用吗？

#### 精选一



