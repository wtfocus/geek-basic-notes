[TOC]

## 17 | 跳表： 为什么 Redis 一定要用跳表来实现有序集合？

+ 前面讲的二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？
+ 实际上，我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造后的数据结构叫作“**跳表（Skip list）**”，也就是今天讲的内容。
+ 跳表这种数据结构随机大家比较陌生，但是，它确实是一种各方面性能都比较优秀的**动态数据结构**，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树。
+ Redis 中的有序集合就是用跳表来实现的。红黑树也可以实现快速的插入、删除和查找操作。**那 Redis 为什么会选择用跳表来实现有序集合？**为什么不用红黑树呢？

### 如何理解"跳表"？

+ 对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表，这样查找的效率就会很低，时间复杂度很高，是`O(n)`。
+ ![](http://ww1.sinaimg.cn/large/006tNc79ly1g5ccjwd0koj30vq07gt8t.jpg)
+ 那怎么来提高查找效率呢？如果像图中那样，**对链表建立一级“索引”**，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作**索引**或**索引层**。
+ 下图中， down 表示 down 指针，指向下一级结点。
+ ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5ccmt6lrtj30vq0di3z0.jpg)
+ 如上图，当我们要找 16 的结点。原来需要遍历 10 个结点，现在只需要遍历 7 个结点。
+ 这个例子中，我们看出，**加了一层索引后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。**那如果再加一级索引，效率会不会提升更多呢？
+ 跟前面建立索引的方式相似，我们在第一级索引的基础上，每两个结点就抽出一个结点到第二级索引。现在，查找 16 ，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。
+ ![](http://ww2.sinaimg.cn/large/006tNc79ly1g5cctifrrpj30vq0if0tg.jpg)
+ 上面的两个例子数据量都不是很大，所以即便加了两级索引，查找效率的提升也并不明显。下面，我画了一个包含 64 个结点的链表，按照前面讲的思路，建立 5 级索引。
+ ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5ccvhkls4j30vq0ho3yz.jpg)
+ 从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点，速度是不是提高了很多？
+ 所以，**当链表长度 n 比较大时，在构建索引之后，查找效率的提升就会非常明显。**
+ 前面讲的，**这种链表加多级索引的结构，就是跳表。**

### 用跳表查询到底有多快？

+ 这里我们分析一下一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？
+ 我把问题分解一下，先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？
    + 按刚才讲的，**每两个结点会抽出一个结点作为上一级索引的结点**。
    + 那第一级结点个数大约就是 n/2，
    + 第二级结点个数大约是 n/4,
    + 第三级结点个数大约是 n/8
    + ……
    + 依次类推，**第 k 级索引的结点个数是第 k-1 级索引结点个数的 1/2，那第 k 级索引结点个数就是 n/($n^k$)**
+ 假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得出 n/($n^h$)=2，从而求得  h=$log_2n$-1。如果包含原始链表这一层，整个跳表的高度就是 $log_2n$。
+ 我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表查询一个数据的时间复杂度就是`O(m*logn)`。
+ 这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是 m = 3，为什么是 3 呢？
    + 假设我们要查找的数据是 x，
    + 在第 k 级索引中，我们遍历到 y 结点后，发现 x 大于 y，小于后面的结点 z。所以，我们通过 y 的down 指针，从第 k 级索引下降到第 k-1 级索引。
    + 在 k-1 级索引中，y 到 z 之间只有 3 个结点（包含 y 和 z）。所以，我们在 k-1 级索引中最多只需要遍历 3 个结点。
    + 依此类推，第一级索引都最多只需要遍历 3 个结点。
    + ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5d66xcbkyj30vq0c7mxl.jpg)
+ 通过上面的分析，在**跳表中查询任意数据的时间复杂度是 `O(logn)`。**
+ 换句话说，我们其实用**单链表实现了二分查找**。
+ 不过，天下没有免费的午餐，这种查询效率的提升，前提是建立多级索引，也就是前面讲的**空间换时间的设计思路。**

### 跳表是不是很浪费内存?

+ 我们来分析一下跳表的时间复杂度。
+ 假设，原始链表大小为 n ，第一级索引大约在 n/2 个结点，第二级索引大约在 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。
+ 如果，我们把每层索引的结点数写出来，就是一个等比数列。如下图
+ ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5d6e2fa0xj30vq09f0st.jpg)
+ 这几级索引结点的总和是 `n/2 + n/4 + n/8 ... 8 + 4 + 2 = n-2`，所以，**跳表的空间复杂度就是 `O(n)`。**也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。
+ 那么，这里有没有办法降低索引占用的内存空间呢？
    + 我们上面都是每两个结点抽一个结点到上级索引，如果我们每三个或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？如下图，
    + ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5d7n2zxhhj30vq0aidfz.jpg)
    + 上图中可以看出，
        + 第一级索引大约 n/3 个结点，
        + 第二级索引大约 n/9 个结点。
        + 每往一级索引，结点个数都除以 3 。
        + 假设，最高级索引结点个数是 1。我们把每级索引的结点个数都写下来，也是一个等比数列。
        + ![](http://ww2.sinaimg.cn/large/006tNc79ly1g5d7pgnsu1j30vq0a0wek.jpg)
        + 通过等比数列求和，总的索引结点大约就是 **n/2**。尽管，空间复杂度还是 O(n)。但，**比上面的每两个结点抽一个结点的索引构建方法，要减少一半的索引结点存储空间。** 
+ 实际上，在软件开发中， 我们不必太过在意索引占用的额外空间。在实际的软件开发中，原始链表中存储的有可能 是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，**所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了**。

### 高效的动态插入和删除

+ 跳表这个动态数据结构，不仅支持查找操作，还支持动态插入、删除操作，而且插入、删除操作的时间复杂度也是 `O(logn)`。
+ 我们现在来看下，如果在跳表中**插入**一个数据，以及它是**如何做到 `Ologn`的时间复杂度的**？
    + 在单链表中， 一旦定位好插入的位置，插入结点的时间复杂度是很低的，就是 `O(1)`。但，这里为了保证原始链表中数据的有序性，我们需要先找到插入的位置，这个查找操作就会比较耗时。
    + 在纯粹的单链表，需要遍历每个结点，来找到插入的位置。但，对于跳表，我们讲过，查找某个结点的时间复杂度是 `O(logn)` 。
    + 下图中，表示了一个跳表的插入过程。
    + ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5f9vn51zjj30vq0nggmi.jpg)
+ 下面我们再来看删除操作。
    + 如果这个结点在索引中也有出现，我们除了删除原始链表中的结点，还要删除索引中的。

### 跳表索引动态更新

+ 当我们不停的往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点间的数据非常多的情况。极端情况下，跳表还会退化成单链表。
+ ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5fa0erdmpj30vq0dpweq.jpg)
+ 作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。
+ **跳表是通过随机函数来维护前面提到的“平衡性”。**
+ 当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？
    + 我们通过一个随机函数，来决定将这个结点插入到哪几级索引中。如下图，比较随机函数生成了值 K，那我们就将这个结点添加到第K 级索引中。
    + ![](http://ww1.sinaimg.cn/large/006tNc79ly1g5faiglkqej30vq0nigml.jpg)
    + 随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。至于随机函数的选择。如果你感兴趣，可以看下 github 上的代码或者 redis 中关于有序集合的跳表实现。

### 解答开篇

+ 为什么 redis 要用跳表来实现有序集合，而不是红黑树？
+ redis 中的有序集合是通过跳表来实现的，严格来讲，其实还用到了散列表。redis 中的有序集合支持的核心操作主要有下面这几个：
    + 插入
    + 删除
    + 查找
    + 按区间查找数据
    + 迭代输出有序序列
+ 其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表一样。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。
+ 对于**按照区间查找数据这个操作，跳表可以做到 `O(logn)` 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。**这样做非常高效。
+ 当然，redis 之所以用跳表来实现有序集合，还有其他原因。如，跳表更容易实现（相比红黑树），而且简单就意味着可读性好，不容易出错。还有跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。
+ 不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现更早一些，很多编程语言中 Map 类型都是通过红黑树来实现的。

### 内容小结 

+ 今天我们讲了跳表这种数据结构。跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速插入、删除、查找操作，时间复杂度都是`O(logn)`。
+ 跳表的空间复杂度是 `O(n)`。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是，作为一种动态数据结构，比起红黑树来说，实现起来还是简单多了。所以很多时候，我们为了代码简单、易读，比起红黑树，我们更倾向用跳表。

### 课后思考

+ 今天，对于跳表的时间复杂度分析，我们分析了每两个结点提取一个结点作为索引的时间复杂度。如果每三个或者五个结点提取一个结点作为上级索引，对应在跳表中查询数据的时间复杂度是多少呢？

#### 精选一

+ 严格来讲，redis 的对象系统中的每种对象实际上都是基于使用场景选择多种底层数据结构实现的。如 ZSET 就是基于“压缩列表”或“跳跃表+字典”（这也跟之前排序中提到的 sort 包实现的思想一样，基于数据规模选择合适的排序算法），体现了 redis 对于性能极致的追求。