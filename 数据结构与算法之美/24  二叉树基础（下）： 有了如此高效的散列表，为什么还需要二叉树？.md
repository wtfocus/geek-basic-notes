[TOC]

## 24 | 二叉树基础（下）： 有了如此高效的散列表，为什么还需要二叉树？

![](http://ww4.sinaimg.cn/large/006tNc79ly1g5p1s03mukj30vq0hsaan.jpg)

- 今天我们来学习一种特殊的二叉树，**二叉查找树**。它最大的的特点就是：
    - 支持动态数据集合的快速插入、删除、查找操作。
- 我们前面说过，散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是`O(1)`。**既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？**

### 二叉查找树（Binary Search Tree）

- 二叉查找树是一种最常用的类型，也叫二叉搜索树。
    - 为实现快速查找而生。
    - 还支持快速插入、删除一个数据。
- 二叉查找树数据结构要求
    - **在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的的值，而右子树节点的值都大于这个节点的值。**
    - ![img](https://static001.geekbang.org/resource/image/f3/ae/f3bb11b6d4a18f95aa19e11f22b99bae.jpg)

#### 1. 二叉查找树的查找操作

- 思路
    - 先取根节点，如果它等于我们要查找的数据，就返回。
    - 如果要查找的数据比根节点的值小，就在其左子树中递归查找。
    - 如果要查找的数据比根节点的值大，就在其右子树中递归查找。

- 代码

    - ```java
        public class BinarySearchTree {
          private Node tree;
        
          public Node find(int data) {
            Node p = tree;
            while (p != null) {
              if (data < p.data) p = p.left;
              else if (data > p.data) p = p.right;
              else return p;
            }
            return null;
          }
        
          public static class Node {
            private int data;
            private Node left;
            private Node right;
        
            public Node(int data) {
              this.data = data;
            }
          }
        }
        
        ```

    - 

#### 2. 二叉查找树的插入操作

- 思路
    - 二叉查找树的插入过程类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。
        - 如果要插入的数据比节点的数据大，
            - 并且节点的右子树为空，就将新数据直接插到右子节点的位置。
            - 如果不为空，就再递归遍历右子树，查找插入位置。
        - 如果插入的数据比节点数值小，
            - 并且节点的左子树为空，就将新数据插入到左子节点的位置。
            - 如果不为空，就再递归遍历左子树，查找插入位置。
    - ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5pq9cbm4qj30vq0gqmxa.jpg)

- 代码

    - ```java
        public void insert(int data) {
          if (tree == null) {
            tree = new Node(data);
            return;
          }
        
          Node p = tree;
          while (p != null) {
            if (data > p.data) {
              if (p.right == null) {
                p.right = new Node(data);
                return;
              }
              p = p.right;
            } else { // data < p.data
              if (p.left == null) {
                p.left = new Node(data);
                return;
              }
              p = p.left;
            }
          }
        }
        
        ```

    - 

#### 3. 二叉查找树的删除操作

- 思路：
    - 针对要删除节点的子节点个数的不同，我们需要分三种情况处理：
        1. 如果**要删除的节点没有子节点**，我们只需要直接将父节点中，指向要删除节点的指针置为 null。如图中的删除节点 55。
        2. 如果**要删除的节点只有 一个子节点**，我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。如图中的删除节点 13。
        3. 如果**要删除的节点有两个子节点**。我们需要找到这个节点的右子树中最小的节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子节点，那就不是最小节点了）。所以，我们就可以应用上面两条规则来删除这个最小节点。如图中的删除节点 18
    - ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5pvgc061nj30vq0h8t97.jpg)

- 代码

    - ```java
        public void delete(int data) {
          Node p = tree; // p 指向要删除的节点，初始化指向根节点
          Node pp = null; // pp 记录的是 p 的父节点
          while (p != null && p.data != data) {
            pp = p;
            if (data > p.data) p = p.right;
            else p = p.left;
          }
          if (p == null) return; // 没有找到
        
          // 要删除的节点有两个子节点
          if (p.left != null && p.right != null) { // 查找右子树中最小节点
            Node minP = p.right;
            Node minPP = p; // minPP 表示 minP 的父节点
            while (minP.left != null) {
              minPP = minP;
              minP = minP.left;
            }
            p.data = minP.data; // 将 minP 的数据替换到 p 中
            p = minP; // 下面就变成了删除 minP 了
            pp = minPP;
          }
        
          // 删除节点是叶子节点或者仅有一个子节点
          Node child; // p 的子节点
          if (p.left != null) child = p.left;
          else if (p.right != null) child = p.right;
          else child = null;
        
          if (pp == null) tree = child; // 删除的是根节点
          else if (pp.left == p) pp.left = child;
          else pp.right = child;
        }
        
        ```

- 扩展

    - 关于二叉树的删除操作，还有一个非常简单、取巧的方法，**就是单纯将要删除的节点，标记为“已删除”，**但是，并不真正从树中将这个节点去掉。这样原来删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也没有增加插入、查找操作代码实现的难度。

#### 4. 二叉查找树的其他操作

- **快速地查找最大节点和最小节点、前驱节点和后继节点**
- **中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 `O(n)`，非常高效。**

### 支持重复数据的二叉查找树

- 如果存储的两个对应键值相同，这种情况怎么处理呢？这里有两种解决方法：
    1. 二叉查找树中每一个节点不仅会存储一个数据，我们通过链表和支持动态扩容的数组等数据结构，把相同的值存储在同一节点了。
    2. 此方法不好理解，但，更加优雅。
        - 每个节点仍然只存储一个数据。在查找**插入**位置的过程中，如果碰到一个节点值，与要插入的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，**把这个新插入的数据当作大于这个节点的值来处理。**
        - ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5pw0y98lwj30vq0ffq2x.jpg)
        - 当**查找**时，**遇到值相同的节点，我们并不停止查找操作，而是继续在右子树查找，直到遇到叶子节点，才停止**。这样就可以把键值等于要查找值的所有节点都找出来 。
        - ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5pw3eavzdj30vq0g1aa2.jpg)
        - 对于**删除**操作。先查找到要删除的节点，然后按前面讲的删除操作方法，依次删除。
        - ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5pw4p5r99j30vq0gwwen.jpg)

### 二叉查找树的时间复杂度分析

- 我们来分析一下，二叉查找树的插入、删除、查找操作的时间复杂度。

- ![](http://ww2.sinaimg.cn/large/006tNc79ly1g5r1j5m17kj30vq0l974l.jpg)

- 图一中第一个二叉查找树，根节点左右子树极度不平衡，已经退化成链表，所以查找的时间复杂度是 `O(n)`。

- 从前面的图、例子中，可以看出，**插入、删除、查找时间复杂度其实都是跟树的高度成正比，也就是 O(hight)。**这样的话，现在的问题就转变成了一个“如何求一棵包含 n 个节点的完全二叉树的高度？”

- 树的高度就等于最大层数减一。

    - 从图中可以看出，n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第二层包含 4 个节点，依次类推，**下面一层节点个数是上一层的 2 倍，第 K 层节点个数就是 `$2^(K-1)$`。**

    - 对于完全二叉树来说，它包含的节点个数在 1 个到 `2^(L-1)` 个之间（假设最大层数是 L）。如果，我们把每一层节点个数加起来就是总的节点个数 n。如下：

    - ```
        n >= 1+2+4+8+...+2^(L-2)+1
        n <= 1+2+4+8+...+2^(L-2)+2^(L-1)
        ```

    - 注：

        - `2^(L-2)` 表示倒数第二层节点个数

    - 借助等比数列的求和公式，我们可以计算出 L 的范围就是 [$log_2(n+1)$, $log_2n + 1$]。

    - 完全二叉树的层数小于等于 $log_2n+1$，也就是说完全二叉树的高度小于等于 $log_2n$。

- 显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。

### 解答开篇

- 散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 `O(1)`，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 `O(logn)`。那我们为什么还要用二叉查找树呢？
- 有如下几个原因：
    1. 排序
        - 散列表的数据是无序存储的，要输出有序数据，需要先进行排序。对于二叉查找树来说，我们只需要中序遍历，就可以在`O(n)` 的时间复杂度内，输出有序的数据序列。
    2. 稳定
        - 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 `O(logn)`。
    3. 效率
        - 尽管散列表的查找等操作的时间复杂度是常量级，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际查找速度不一定比 `O(logn)` 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
    4. 实现
        - 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。平衡二叉查找树只需要考虑平衡性这一个问题，而这个问题的解决方法比较成熟、固定。
    5. 散列冲突
        - 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。
- 总结
    - 两者存在并不冲突，在实际开发过程中，需要结合具体的需求来选择使用哪一个。

### 内容小结

- 二叉查找树（一种特殊的二叉树），它支持快速查找、插入、删除操作。
- 二叉查找树中，
    - （对于没有重复数据）每个节点的值都大于左子树节点的值，小于右子树节点的值。
    - （存在重复数据情况），这里有两种构建方法
        1. 让每个节点存储多个值相同的数据。
        2. 每个节点存储一个数据，稍加改造原来的插入、删除、查找操作即可。
- 在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。
    - 两种极端情况的时间复杂度分别是
        - 二叉树退化成链表： `O(n)` 
        - 完全二叉树： `O(logn)`
    - 为了避免时间复杂度的退化，针对二叉查找树，我们又设计了一种更加复杂的树——平衡二叉查找树，时间复杂度可以做到稳定的 `O(logn)`，下节来讲。

### 课后思考

- 如果通过编程，求出一棵给定二叉树的确切高度呢？

#### 精选一

- 确定二叉树高度有两种思路
    1. 尝试优化思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个 `+ 1`
    2. 采用层次遍历的方式，每一层都记录下当前队列的长度，这 个是队尾，每一层队头从 0 开始。然后遍历一个元素，队头下标 `+1`。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层开始遍历的时候，树的高度`+1`。最后队列为空，就能得到树的高度。