[TOC]

## 19 | 散列表（中）： 如何打造一个工业级水平的散列表？

![](http://ww3.sinaimg.cn/large/006tNc79ly1g5fe855tihj30vq0i30t9.jpg)

1.  开篇题：
    -   **如何设计一个可以对应各种异常情况的工业级散列表，来避免散列冲突的情况下，散列表性能急剧下降，并且能抵抗散列碰撞攻击？**

### 散列函数

1.  散列函数的重要性
    -   决定了散列表**冲突的概率**大小
    -   也决定了散列表的**性能**
2.  什么才是好的散列函数呢

    - 散列函数的设计**不能太复杂**。
    - 散列函数生成的值要尽可能**随机并且均匀**分布

### 装载因子

1. 装载因子

    >   表示 Hash 表中元素的填满程度
    >
    >   
    >
    >   装载因子 = 填入表中的元素个数 / 散列表的长度

2.　装载因子越大

    -   理论：散列表中的元素越**多**，空闲位置越**少**，散列冲突的概率就越**大**。
    -   结合实际：不仅插入数据的过程要**多次寻址**或者**拉很长的链**，查找的过程也会因此变得很**慢**。
    -   影响范围：静态散列表、**动态散列表**（重点）

3. 针对　“动态散列表装载因子变大”　的解决方案：**动态扩容**

    -   ![img](imgs/67d12e07a7d673a9c1d14354ad029443-3925847.jpg)

    -   插入操作的**时间复杂度**是多少呢？
        -   最好是 `O(1)`
        -   最坏是 `O(n)`
        -   均摊是`O(1)`

### 动态扩容优化

1.  “一次性”扩容
    
    -   会造成插入数据**很慢**。甚至无法接受。
2.  “分批”扩容
    -   当装载因子触达阈值后，**我们只申请新空间**，但并不将老数据搬移到新散列表中。
    -   有新数据要插入时，我们将**新数据插入新散列表**中，并且从老的散列中拿出一个数据放到新散列表。
    -   每次插入一个数据到散列表，我们都重复上面的过程。
    -   ![img](imgs/6d6736f986ec4b75dabc5472965fb9cb-3926204.jpg)

	-   查询操作
        - 先从新散列表中查找，如果没有找到，再去老散列表中查找 。
    
    -   时间复杂度都是 `O(1)`。

### 散列冲突的解决方法

1. **开放寻址法**
- 优点
        - 数据存储在**数组**中，可以**有效地利用 CPU 缓存加快查询速度**。
        - **序列化**起来比较简单
    - 缺点
        - 删除数据时，需要特殊标记已删除掉的数据。
        - 冲突的代价更高。
        - 更浪费内存空间。
    - 适用场景
        - 数据量比较小，装载因子小的时候。
    
2. **链表法**
- 优点
        - 对内存利用率高
        - 对大装载因子的容忍度更高
        - 更加灵活，支持更多优化策略
    - 缺点
        - 对于比较小的对象的存储，**是比较消耗内存的**
        - 对 CPU 缓存不是友好的
    - 适用场景
        - 适合存储大对象、大数据量的散列表

### 工业级散列表（HashMap）分析

1. 初始大小

    -   默认初始化的大小是 16
    
2. 装载因子和动态扩容

    - 装载因子默认是 0.75
    - 每次扩容为原来的两倍大小。

3. 散列冲突解决方法

    - HashMap 底层采用**链表法**来解决冲突
    - JDK 1.8 中，为了对 HashMap 做进一步优化，引入了**红黑树**。
        - 当链表长度太长（默认超过 8）时，链表就转换为红黑树。
        - 当结点少于 8 个的时，又会转化为链表。

4. 散列函数

    -   ```java
        int hash(Object key) {
            int h = key.hashCode()；
                return (h ^ (h >>> 16)) & (capitity -1); //capicity 表示散列表的大小
        }
        
        // 返回的是 Java 对象的 hash code
        // 如下是 String 类型的对象 hashCode()
        public int hashCode() {
            int var1 = this.hash;
            if(var1 == 0 && this.value.length > 0) {
                char[] var2 = this.value;
                for(int var3 = 0; var3 < this.value.length; ++var3) {
                    var1 = 31 * var1 + var2[var3];
                }
                this.hash = var1;
            }
            return var1;
        }
        ```

    -   


### 解答开篇

1.  开篇题：“**如何设计一个工业级的散列函数？**”
2.  思路
    1.  工业级的散列表应该具有哪些**特性**？

		- 支持快速查询、插入、删除操作。
        - 内存占用合理
        - 性能稳定
    2. **如何实现？**
        - 设计一个合适的**散列函数**。
        - 定义**装载因子**阈值，并且设计**动态扩容策略**。
        - 选择**合适的散列冲突解决方法**。

### 课后思考

1.  在你熟悉的编程语言中，哪些数据类型底层是**基于散列表实现**的？散列函数是**如何设计**的？**散列冲突**是通过哪种方法解决的？是否支持**动态扩容**？

