[toc]

## 12 | 排序（下）：如何用快排思想在 O(n) 内查找第 K 大元素？

1.  **归并排序**和**快速排序**
    -   适合大规模的数据排序
    -   时间复杂度 O(nlogn) 
    -   分治思想

### 归并排序

1.  核心思想

    -   **分治思想**

    -   我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

2.  分解图

    -   ![img](imgs/db7f892d3355ef74da9cd64aa926dc2b.jpg)

3.  实现

    -   实现思想：递归

    -   递推公式：

        -   ```
            递推公式：
            merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
            
            终止条件：
            p >= r 不用再继续分解
            ```

    -   伪代码

        -   ```c
            
            // 归并排序算法, A是数组，n表示数组大小
            merge_sort(A, n) {
              merge_sort_c(A, 0, n-1)
            }
            
            // 递归调用函数
            merge_sort_c(A, p, r) {
              // 递归终止条件
              if p >= r  then return
            
              // 取p到r之间的中间位置q
              q = (p+r) / 2
              // 分治递归
              merge_sort_c(A, p, q)
              merge_sort_c(A, q+1, r)
              // 将A[p...q]和A[q+1...r]合并为A[p...r]
              merge(A[p...r], A[p...q], A[q+1...r])
            }
            ```

    -   merge 函数分解图

        -   ![img](imgs/95897ade4f7ad5d10af057b1d144a22f.jpg)

    -   merge 函数伪代码

        -   ```c
            
            merge(A[p...r], A[p...q], A[q+1...r]) {
              var i := p，j := q+1，k := 0 // 初始化变量i, j, k
              var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
              while i<=q AND j<=r do {
                if A[i] <= A[j] {
                  tmp[k++] = A[i++] // i++等于i:=i+1
                } else {
                  tmp[k++] = A[j++]
                }
              }
              
              // 判断哪个子数组中有剩余的数据
              var start := i，end := q
              if j<=r then start := j, end:=r
              
              // 将剩余的数据拷贝到临时数组tmp
              while start <= end do {
                tmp[k++] = A[start++]
              }
              
              // 将tmp中的数组拷贝回A[p...r]
              for i:=0 to r-p do {
                A[p+i] = tmp[i]
              }
            }
            ```

4.  分析

    -   一、归并排序是稳定的排序算法吗？
        -   归并排序是一个**稳定**的排序算法。
        -   关键在于 merge 函数
        -   在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p…q]中的元素放入 tmp 数组。
    -   二、归并排序的时间复杂度是多少？
        -   最好/最坏/平均情况，时间复杂度都是 **O(nlogn)**
        -   归并排序的执行效率**与要排序的原始数组的有序程度无关**，所以其时间复杂度是非常稳定的。
    -   三、归并排序的空间复杂度是多少？
        -   归并排序**不是原地排序算法**
        -   归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。
        -   空间复杂度是 **O(n)**。

### 快速排序

1.  核心思想

    -   如果要排序的数组中下标从 p 到 r 间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot (分区点)。

    -   在遍历 p 到 r 间的数据时，将小于 pivot 的放左边，将大于 pivot 放右边，将 pivot 放到蹭。经过这一步骤后，数据就被分成三个部分。
    -   根据分治、递归的思想，我们可以用递归排序下标从 p 到 q - 1 间的数据和下标从 q + 1 到 r 间的数据，直到区间缩小为 1, 就说明所有数据都有序了。

2.  分解图

    -   ![img](imgs/4d892c3a2e08a17f16097d07ea088a81.jpg)

3.  实现

    -   递推公式

        -   ```
            递推公式：
            quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)

            终止条件：
            p >= r
            ```

    -   代码

        -   ```c
            // 快速排序，A 是数组，n 表示数组的大小
            quick_sort(A, n) {
              quick_sort_c(A, 0, n-1)
            }
            // 快速排序递归函数，p,r 为下标
            quick_sort_c(A, p, r) {
              if p >= r then return
    
              q = partition(A, p, r) // 获取分区点
              quick_sort_c(A, p, q-1)
              quick_sort_c(A, q+1, r)
            }
    
            
            ```
        
    -   partition 函数，思想
    
        -   随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r]分区，函数返回 pivot 的下标。
        -   如果我们希望快排是**原地排序算法**，那它的空间复杂度得是 O(1)，那 partition() 分区函数就不能占用太多额外的内存空间，我们就需要在 A[p…r]的原地完成分区操作。
    
    -   partition 函数，伪代码，实现原地排序（空间复杂度 O(1)）
    
        -   ```C
            
            partition(A, p, r) {
              pivot := A[r]
              i := p
              for j := p to r-1 do {
                if A[j] < pivot {
                  swap A[i] with A[j]
                  i := i+1
                }
              }
              swap A[i] with A[r]
              return i
            
            ```
    
    -   partition 函数，分解图
    
        -   ![img](https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg)
    
4.  快排 vs 归并

    -   归并排序的处理过程是**由下到上**
    -   快排正好相反，它的处理过程是**由上到下**

    -   ![img](imgs/aa03ae570dace416127c9ccf9db8ac05.jpg)

5.  分析

    -   快排是一种原地、不稳定的排序算法。
    -   在大部分情况下的时间复杂度都可以做到 **O(nlogn)**，只有在极端情况下，才会退化到 **O($n^2$)**。而且，我们有很多方法将这个概率降到很低，如何来做，后面再讲。

### 解答开篇

1.  思路
    1.  快排的核心思想就是**分治**和**分区**，我们可以利用分区的思想，来解答开篇的问题：O(n) 的时间复杂度内求无序数组中的第 K 大元素。（如：4，2，5，12，3这样一组数据，第 3 大元素就是 4。）
    2.  我们选择数组区间 `A[0...n-1]` 的最后一个元素 `A[n-1]` 作为 pivot，对数组 A[0...n-1] 原地分区，这样数组就分成了三部分，`A[0..p-1]`,`A[p]`, `A[p+1...n-1]`。
    3.  如果 p+1=K，那 A[P] 就是求解元素。
    4.  如果 K>p+1，那第 K 大元素出现在 `A[p+1...n-1]` 区间，我们再按照上面的思路递归地在 A[p+1...n-1] 这个区间内查找。
    5.  如果 K<p+1，那我们就在 A[0...p-1] 区间内查找。

2.  时间复杂度

+ 我们再来看看，为什么上述解决思路的时间复杂度是 O(n) ?
    + 第一次分区查找，我们需要对大小为 n 个数组执行分区操作，需要遍历 n 个元素。
    + 第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。
    + 依次类推，直到区间缩小为 1。
    + 最后的和等于 `2n-1`。所以，上述解决思路的时间复杂度为 **O(n)**。

### 课后思考 

1.  现在你有 10 个接口访问日志，每个日志文件大小约 300MB ，每个文件里的里都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，全并后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速” 的将这 10 个日志文件合并吗？

#### 精选留言

1.  #峰

    >   每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。
    >
    >   这个空间复杂度为常数，但没能很好利用1g内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是一样O(n)。

2.  #李建辉

    >   先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，
    >
    >   然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，
    >
    >   然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 
    >
    >   这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存，这是我想出的认为最好的操作了，希望老师指出最佳的做法！！！