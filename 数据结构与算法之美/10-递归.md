[toc]

## 10|递归：如何用三行代码找到“最终推荐人”？

### 定义

1.  **去的过程叫“递”， 回来的过程叫“归”**
2.  基本上所有的递归问题都可以用**递推公式**来表示

### 需要满足的三个条件

1.  一个问题的解可以**分解**为几个子问题解
2.  这个问题与分解后的**子问题**，**除了数据规模不同，求解思路完全一样**

3.  存在递归**终止条件**

### 如何实现

1.  步骤

    -   写出**递推公式**（关键）
    -   找到**终止条件**（关键）

    -   递推公式 => 递归代码

2.  理解递归

    -   把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

### 注意点

1.  警惕**堆栈溢出**
    -   原因：系统栈或者虚拟机栈空间有限。
    -   解决方案：
        -   限制调用**最大深度**
        -   适用于深度较小的场景

2.  警惕**重复计算**
    -   递归分解图
        -   ![img](imgs/e7e778994e90265344f6ac9da39e01bf.jpg)
    -   解决方案：
        -   通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。

### 递归 => 非递归

1.  示例：

    -   需求：“电影院的例子”

    -   递推公式

    -   ```
        
        f(n)=f(n-1)+1 其中，f(1)=1
        ```

    -   递归代码

    -   ```java
        
        int f(int n) {
          if (n == 1) return 1;
          return f(n-1) + 1;
        }
        ```

    -   非递归代码

    -   ```java
        
        int f(int n) {
          int ret = 1;
          for (int i = 2; i <= n; ++i) {
            ret = ret + 1;
          }
          return ret;
        }
        ```

2.  小结

    -   将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。

### 内容小结

1.  优势
    -   高效、简洁的编码技巧
2.  劣势
    -   堆栈溢出、重复计算、函数调用耗时多、空间复杂度高

### 课后思考

+ 我们平时调试代码喜欢用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调用方式。对于递归代码，你有什么好的调试方法呢？

#### 精选留言

1.  #博金

    >   调试递归:
    >
    >   1.打印日志发现，递归值。
    >
    >   2.结合条件断点进行调试。