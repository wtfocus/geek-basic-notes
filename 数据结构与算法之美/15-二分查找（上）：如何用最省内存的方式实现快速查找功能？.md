[TOC]

## 15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？

1. 	思考题：
    + 假设我们有 1000 万整数数据，每个数据占用 8 个字节
    + **如何设计数据结构算法，快速判断某个整数是否出现在这 1000 万数据中？**
    + 我们希望这个功能不要占用太多的内存空间，最多不超过 100MB，你会怎么做呢？

### 二分思想

1.  二分思想：
    -   二分查找针对的是一个**有序**的数据集合，查找思想有点类似分治思想。每次都通过跟区间的**中间元素**对比，将待查找的区间缩小为之前的**一半**，直到找到要查找的元素，或者区间被缩小为 0。
    -   查找流程图
        -   ![img](imgs/8bce81259abf0e9a06f115e22586b829-0986054.jpg)

### 时间复杂度

1.  时间复杂度：**O(logn)** 
    -   ![img](imgs/d1e4fa1542e187184c87c545c2fe4794-0986263.jpg)
    -   其中 n/2k=1 时，k 的值就是总共缩小的次数
    -   通过 n/2k=1，我们可以求得 k=log2n
    -   所以时间复杂度就是 O(logn)

### 非递归实现

1.  代码

    -   ```java
        public int bsearch(int[] a, int n, int value) {
          int low = 0;
          int high = n - 1;
        
          while (low <= high) {
            int mid = (low + high) / 2;
            if (a[mid] == value) {
              return mid;
            } else if (a[mid] < value) {
              low = mid + 1;
            } else {
              high = mid - 1;
            }
          }
        
          return -1;
        }
        
        
        ```

2.  注意
    1. **循环退出条件**

        >   是 `low <= high` 
        >
        >   而不是`low < high`

    2. **mid 取值**

        >   原始写法：`mid = (low + high) / 2`
        >
        >   避免 int 溢出：`low + (high - low)/2`
        >
        >   使用位运算，优化性能：`low + ((high - low)>>1)`

    3. **Low 和 high 更新**

        >   `low = mid + 1`
        >
        >   `high = mid - 1`

### 递归实现

1.  代码

    -   ```java
        // 二分查找的递归实现
        public int bsearch(int[] a, int n, int val) {
          return bsearchInternally(a, 0, n - 1, val);
        }
        
        private int bsearchInternally(int[] a, int low, int high, int value) {
          if (low > high) return -1;
        
          int mid =  low + ((high - low) >> 1);
          if (a[mid] == value) {
            return mid;
          } else if (a[mid] < value) {
            return bsearchInternally(a, mid+1, high, value);
          } else {
            return bsearchInternally(a, low, mid-1, value);
          }
        }
        
        
        ```

### 应用场景的局限性

1.  二分查找依赖的是顺序表结构，简单点就是**数组**
    -   二分查找算法需要按照下标**随机访问**元素。数组按照下标随机访问的时间复杂度是 `O(1)`。

2.  二分查找针对的是**有序**数据
    -   适用于**静态**的数据结构。
    -   不适用动态数据结构。动态数据结构需要使用二叉树（后面再讲）。

3.  **数据量太小不适合**二分查找
    -   如果处理的数据量很小，完全没有必要用二分查找，顺序查找就足够了
    -   例外：
        -   如果**单次数据间比较非常耗时**，不管数据量大小，我都推荐二分查找。

4.  **数据量太大也不适合**二分查找
    -   数组为了支持随机访问的特性，要求**内存空间连续**，对内存的要求比较苛刻。

### 解答开篇

1.  如何在 1000 万个整数中快速查找到某个整数？
    -   将数据存储在**数组**中，内存占用差不多是 80MB，符合内存的限制。
    -   先将这 1000 万数据**排序**，
    -   然后，利用**二分查找**，就可以快速地查找到想到的数据了。
    -   其他数据结构，**不管是散列表还是二叉树，都会需要比较多的额外的内存空间**。所以不适合。

### 课后思考

1. 如果编程实现一个“求一个数的平方根”？要求精确到小数后 6 位。
2. 如果数据使用**链表**来存储，二分查找的时间复杂度就会变得很高，那查找的时间复杂度究竟是多少呢？自己来推导一下。

#### 精选留言

1.  #Jerry银银

    >   说说第二题吧，感觉争议比较大:
    >
    >   
    >
    >   假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):
    >
    >   第一次查找中间点，需要移动指针n/2次；
    >   第二次，需要移动指针n/4次；
    >   第三次需要移动指针n/8次；
    >   ......
    >   以此类推，一直到1次为值
    >
    >   
    >
    >   总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + ...+ 1，这显然是个等比数列，根据等比数列求和公式：Sum = n - 1.
    >
    >   最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同
    >
    >   
    >
    >   但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢