[TOC]

## 18 | 散列表（上）： Word 文档中的单词拼写检查功能是如何实现的？

![](http://ww3.sinaimg.cn/large/006tNc79ly1g5fbgsbhnsj30vq0hs74y.jpg)

+ 在使用 word 这种文本编辑器中，一旦我们在 word 里输入一个错误的英文单词，它就会用标红的方式提示“拼写错误”。**word 的这个单词拼写检查功能，虽然很小，但却非常实用。你有没有想过，这个功能是如何实现的？**

### 散列思想

+ 散列表的英文叫“Hash Table”，我们平时也叫“哈希表”、“Hash 表”
+ **散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没散列表。**

+ 举个例子：
    + 在运动会上，有 89 名运动员，他们的参赛编号分别是 1～89 号。
    + 假设，我们要在编号上加上年级、班级，要用 6 位数字来表示。如 051167。05 是年级，11 是班级，67 是编号。
    + 这里尽管我们不能直接把编号作为数组下标，但，我们可以截取参赛编号后两位作为数组的下标，来存取数据。
    + 这就是典型的散列思想。其中，参赛选手的编号我们叫**键 (key)**或**关键字**。我们把参赛编号转化为数组下标映射的方法叫作**散列函数(或“Hash 函数”、“哈希函数”)**，而散列函数计算得到的值叫作**散列值（或“Hash 值”、“哈希值”）。**
    + ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5fbzw8oktj30vq0ko0tb.jpg)
    + 通过这个例子，我们可以总结出这样的规律：**散列表有的就是数组支持按照下标随机访问的时间，时间复杂度是 `O(1)` 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应数组下标的位置取数据。**

### 散列函数

+ 散列函数在散列表中起着关键作用。

+ 散列函数，顾名思义，是一个函数。可以定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。

+ 就第一个例子，编号就是数组下标，所以 hash(key) 就等于 key。

+ 散列函数的伪代码如下：

+ ```C
    int hash(String key) {
      // 获取后两位字符
      string lastTwoChars = key.substr(length-2, length);
      // 将后两位字符转换为整数
      int hashValue = convert lastTwoChas to int-type;
      return hashValue;
    }
    ```

+ 这里总结了三点散列函数设计基本要求：

    1. 散列函数计算得到的散列值是一个非负整数。
        - 因为数组下标是从 0 开始的
    2. 如果 `key1 = key2`， 那 `hash(key1) == hash(key2)`。
    3. 如果 `key1 != key2`，那 `hash(key1) != hash(key2)`。
        - 实际情况中，要找到一个不同 key 对应的散列值都不一样的散列函数，几乎是不可能的。即使像业界著名的 md5，sha，crc 等哈希算法，也无法完全避免这种**散列冲突**。而且，因为数组存储的空间有限，也会加大散列冲突的概率。
        - 所以，我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突的问题，我们需要通过其他途径来解决。

### 散列冲突

- 这里介绍两种常用的散列冲突解决方法，开放寻址法（open addressing） 和 链表法（chaining）。

#### 1. 开放寻址法

- 开放寻址法的核心思想是，**如果出现散列冲突，我们就重新探测一个空闲的位置，将其插入。**如果探测新的位置呢？我先讲一种简单的探测方法，**线性探测（Linear Probing）**。

-  当我们往散列表中**插入**数据时，

    - **如果某个数据经过散列函数散列后，存储位置已经被占用了，我们就从当前位置开始，依次住后查找，看是否有空间位置，直到找到为止。**
    - 如下图，黄色色块表示空闲位置，橙色色块表示已经存储了数据。
    - ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5fcoq445hj30vq0eqt8u.jpg)
    - 从图中可以看出，散列表的大小为 10 ，在 x 元素经过 hash 算法后，被散列到位置下标为 7 的位置，如果这个位置已经有数据了，所以就产生了冲突，于是我们就顺序地往后一个一个找，看有没有空间的位置。遍历到尾部都没有空闲位置，于是就再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。

- **查找**数据时

    - 类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。
    - 如果相等，说明就是我们要找的元素。
    - 否则，就顺序往后依次查找。
    - 如果遍历到数组空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。
    - ![img](https://static001.geekbang.org/resource/image/91/ff/9126b0d33476777e7371b96e676e90ff.jpg)
    - 线性探测法其实存在很大问题。当散列表中插入数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况时间复杂度为 `O(n)`。

- 对于开放寻址冲突解决方法，除了线性探测法外，还有另外两种较经典的探测方法，**二次探测（Quadratic probing）**和**双重散列（Double hashing）**。

- 不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能的保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用**装载因子（load factor）**来表示空位的多少。

- ```
    散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
    
    ```

- 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

#### 2. 链表法

- 链表法是一种列加常用的散列冲突解决方法，相比开放寻址法，它要简单很多。
- 如下图，在散列表中，每个“桶（backet）” 或“槽（slot）” 会对应一条链表，所以散列值相同的元素我们都放到相同的槽位对应的链表中。
- ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5fdd4rnrij30vq0hsjrx.jpg)
- 插入时
    - 只需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可。时间复杂度是 `O(1)`。
- 查找、删除时
    - 同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。
    - 那这里的时间复杂度是多少呢？
    - 实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 `O(k)`。对于散列比较均匀的散列函数来说，理论上讲，`k = n/m`，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。

### 解答开篇

+ 开篇思考：word 文档中单词拼写检查功能是如何实现的？
    + 常用英文单词有 20 万个左右，假设单词平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占用 2 MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以，我们可以用散列表来存储整个英文单词词典。
    + 当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找 。如果找到说明拼写正确，如果没查找到，说明拼写有问题，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。

### 内容小结

- 今天我讲了一些比较基础、比较偏理论的散列表知识，包括散列表的由来、散列函数、散列冲突的解决方法。
- 散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是**散列函数设计**和**散列冲突解决**。

### 课后思考

1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

#### 精选一

1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
    1. 遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数最大值值 K ，时间复杂度 `O(n)`。
    2. 如果 K 不是很大，可以使用桶排序，时间复杂度 `O(n)`。
    3. 如果 K 很大，就使用快排，时间复杂度是 `O(nlogn)`。
2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？
    1. 以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。
    2. 再遍历第二个字符串数组，以字符串为 key 在散列中查找，如果 value 大于零，说明存在相同字符串。时间复杂度为 `O(n)`。