[TOC]

## 23 | 二叉树基础（上）： 什么样的二叉树适合用数组来存储？

![](http://ww4.sinaimg.cn/large/006tNc79ly1g5ops73gz3j30vq0hs74r.jpg)

- **二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？**

### 树（Tree）

- 观察下图中的树（Tree）
- ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5optr4e7mj30vq0kbjrn.jpg)
- 如下图中，
    - A 就是 B 的**父节点**，
    - B 是 A 的**子节点**。
    - B，C，D 这三个节点的父节点是同一节点，所以，它们互称**兄弟节点**。
    - 我们把没有父节点的的节点叫**根节点**，也就是图中的 E。
    - 我们把没有子节点的节点叫作**叶子节点或者叶节点**。如，G, H, I, J, K, L。
- ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5optr4e7mj30vq0kbjrn.jpg)
- 关于“树”，还有三个较相似的概念，如下图所示：
- ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5oq296kclj30vq0fp3zg.jpg)
    - 高度（Height）
        - 从下往上，计数起点是 0。
    - 深度（Depth）
        - 从上往下，计数起点是 0。
    - 层（Level）
        - 从上往下，计数起点是 1。
- 图例说明：
    - ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5oq3una0dj30vq0fu3yl.jpg)
    - 

### 二叉树（Binary Tree）

- 二叉树，顾名思义，每个节点最多两个叉，也就是两个子节点，分别是**左子节点**和**右子节点**。
- 二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。
- ![](http://ww4.sinaimg.cn/large/006tNc79ly1g5oqb5bkboj30vq0hnaab.jpg)
- 如上图中，有两个比较特殊的二叉树，分别是 2， 3。
    - 编号 2 的二叉树，**叶子节点全都在最底层，除了叶子节点外，每个节点都有左右两个子节点**，这种二叉树叫作**满二叉树**。
    - 编号 3 的二叉树中，**叶子节点都在最底下两层，最后一层的叶子节点都靠左排序，并且除了最后一层，其他层的节点个数都要达到最大**，这种二叉树叫作**完全二叉树**。
- 理解完全二叉树，看图理解：
    - ![img](https://static001.geekbang.org/resource/image/18/60/18413c6597c2850b75367393b401ad60.jpg)
- **如何表示（或者存储）一棵二叉树？**
    - **链式存储法**
        - 如下图中，每个节点有三个字段，其中一个存储数据，另外两个是指向左右节点的指针。
        - 我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树串起来。
        - ![](http://ww2.sinaimg.cn/large/006tNc79ly1g5oqnqwk3cj30vq0kejro.jpg)
    - **顺序存储法**
        - 如下图，我们把根节点存储在下标 `i=1` 的位置，那左子节点存储在下标 `2 * i = 2` 的位置，右子节点存储在 `2*i+1=3` 的位置。以此类推。反过来，下标为 i/2 的位置存储的就是它的父节点。我们只要知道根节点存储的位置，就可以通过下标计算，把整棵树串起来。
        - ![](http://ww1.sinaimg.cn/large/006tNc79ly1g5oqr7c88ej30vq0gsq33.jpg)
        - 我刚刚举的是一棵完全二叉树，所以，仅仅浪费了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间，如下图
        - ![](http://ww1.sinaimg.cn/large/006tNc79ly1g5orzf2ykkj30vq0g9q33.jpg)
        - 所以，**如果是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式**。因为数组存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层子节点都靠左的原因。
        - 其实，堆就是一个完全二叉树，最常用的存储方式就是数组。

### 二叉树的遍历

- 经典的方法有三种：

    - 前序遍历
    - 中序遍历
    - 后序遍历

- 前序遍历

    - 对于树中任意节点来说，先打印这个节点，再打印它的左子树，最后打印它的右子树。

- 中序遍历

    - 对于树中任意节点来说，先打印它的左子树，再打印它本身，最后打印它的右子树。

- 后序遍历

    - 对于树中任意节点来说，先打印它的左子树，然后再打印它的左子树，最后打印这个节点本身。

- ![](http://ww3.sinaimg.cn/large/006tNc79ly1g5osayu89vj30vq0g6gmk.jpg)

- 实际上， **二叉树的前、中、后序遍历就是一个递归的过程。**

    - **递推公式**如下

    ```
    前序遍历的递推公式：
    preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)
    
    中序遍历的递推公式：
    inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)
    
    后序遍历的递推公式：
    postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
    
    ```

    - **递归代码**如下

- ```
    void preOrder(Node* root) {
      if (root == null) return;
      print root // 此处为伪代码，表示打印 root 节点
      preOrder(root->left);
      preOrder(root->right);
    }
    
    void inOrder(Node* root) {
      if (root == null) return;
      inOrder(root->left);
      print root // 此处为伪代码，表示打印 root 节点
      inOrder(root->right);
    }
    
    void postOrder(Node* root) {
      if (root == null) return;
      postOrder(root->left);
      postOrder(root->right);
      print root // 此处为伪代码，表示打印 root 节点
    }
    
    ```

- **时间复杂度**

    - 从前面的前、中、后序遍历的顺序图，可以看出，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点个数 n 成正比，也就是说，二叉树遍历的时间复杂度是 `O(n)`。

### 解答开篇 & 内容小结

- 今天，我们讲了一种非线性表数据结构，树。
- 有几个常用概念需要你掌握：
    - 根节点
    - 叶子节点
    - 父节点
    - 子节点
    - 兄弟节点
    - 深度
    - 层数
    - 树的高度
- 两种比较特殊的树
    - 满二叉树（是完全二叉树的一种特殊情况）
    - 完全二叉树
- 存储
    - 链式存储
    - 数组顺序存储
        - 比较适合完全二叉树
- 操作
    - 前、中、后序遍历
- 时间复杂度
    - `O(n)`
- 代码实现
    - 递归

### 课后思考

1. 给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？
2. 如何实现二叉树按层遍历？

#### 精选一

